<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<meta name="description" content="OpenCyc is the open source version of the Cyc technology, the worlds largest and most complete general knowledge base and commonsense reasonging engine.  Cycorp, the builders of Cyc, have set up an independent organization, OpenCyc.org, to disseminate and administer OpenCyc, and have committed to a pipeline through which all current and future Cyc technology will flow into ResearchCyc (available for R&D in academia and industry) and then OpenCyc.">
<meta name="keywords" content="opencyc,open source,free software,intelligent software,bots,Cycorp,
cyc,artificial intelligence,expert system,ontology,ai,software,natural language,common sense,intelligent computing,knowledge management,semantic integration,knowledge,doug lenat,logic,symbolic,software tool,predicate calculus,enterprise computing,cio,decision support,data warehouse,hal 9000,knowledge base,knowledge server">
<title>OpenCyc</title>
</head>

<body bgcolor="#FFFFFF">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
    <tr>
        <td><img
        src="images/opencyc3-logo-1.gif"
        width="268" height="70"></td>
        <td width="50">&nbsp;</td>
        <td align="right" valign="bottom" width="350"><p
        align="right"><font color="#3399FF" size="3"
        face="Arial"><strong>Formalized Common Knowledge</strong></font></p>
        </td>
    </tr>
</table>


<table border="0" cellpadding="0" cellspacing="0" width="100%"
bordercolor="#FFFFFF" bordercolordark="#FFFFFF"
bordercolorlight="#FFFFFF">
    <tr>
        <td width="75" height="10">&nbsp;</td>
        <td height="10">&nbsp;</td>
        <td valign="top" bgcolor="#3399FF" bordercolor="#000080"
        height="10"><img
        src="images/menubar9.gif"
        width="354" height="13"></td>
        <td valign="top" width="10" bgcolor="#3399FF" height="10">&nbsp;</td>
        <td bgcolor="#3399FF" height="10">&nbsp;</td>
        <td bgcolor="#3399FF" height="10">&nbsp;</td>
        <td valign="top" bgcolor="#3399FF" height="10">&nbsp;</td>
    </tr>
    <tr>
        <td height="30">&nbsp;</td>
        <td height="30">&nbsp;</td>
        <td height="30">&nbsp;</td>
        <td height="30">&nbsp;</td>
        <td height="30">&nbsp;</td>
        <td height="30">&nbsp;</td>
        <td height="30">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top"><br>
        <p><img src="images/small_bullet.gif" width="17"
        height="7"><a href="http://www.opencyc.org/"><font
        size="2">Home</font></a></p>
        <p><img src="images/small_bullet.gif" width="17"
        height="7"><a
        href="http://sourceforge.net/projects/opencyc/"><font
        size="2">Projects</font></a></p>
        <p><img src="images/small_bullet.gif" width="17"
        height="7"><a href="/OpenCyc_org/faq/faq1_html"><font size="2">FAQ</font></a></p>
        <p><img src="images/small_bullet.gif" width="17"
        height="7"><a href="doc"><font
        size="2">Documentation</font></a></p>
        <p><img src="images/small_bullet.gif" width="17"
        height="7"><a class="none" 
        href="http://www.opencyc.org/releases/"><font
        size="2">Releases</font></a></p>
        <p><img src="images/small_bullet.gif" width="17"
        height="7"><a
        href="http://sourceforge.net/project/showfiles.php?group_id=27274"><font
        size="2">Downloads</font></a></p>
        <p><img src="images/small_bullet.gif" width="17"
        height="7"><a
        href="http://sourceforge.net/forum/?group_id=27274"><font
        size="2">Discussion</font></a></p>
        <p><img src="images/small_bullet.gif" width="17"
        height="7"><a
        href="http://sourceforge.net/news/?group_id=27274"><font
        size="2">News</font></a></p>
        <p><img src="images/small_bullet.gif" width="17"
        height="7"><a
        href="http://www.opencyc.org/license"><font
        size="2">License</font></a></p>
        <p><img src="images/small_bullet.gif" width="17"
        height="7"><a
        href="/OpenCyc_org/Wiki"><font
        size="2">Wiki</font></a></p>
        </td>
        <td width="20"><!--webbot bot="HTMLMarkup" startspan -->&nbsp;<!--webbot
        bot="HTMLMarkup" endspan --></td>
<td valign="top">

<small><a href="opencycapi_print"><img src="/OpenCyc_org/images/printit.gif" border=0>printable version</a></small>
<p>
<center>

<h1>
The OpenCyc SubL Application Programming Interface 
<br>
(OpenCyc SubL API, a.k.a. Cyc API)
</h1>

<br>

February 25, 2002

<br>

<strong> 
Version 1.0
</strong>

<br><br>

Copyright 1997 - 2003 Cycorp, Inc.<br>
</center>
<p><a href="http://www.opencyc.org">OpenCyc.org</a>
<p><a href="http://www.sourceforge.net/projects/opencyc">OpenCyc at SourceForge</a>
<p>
THIS SOFTWARE AND KNOWLEDGE BASE CONTENT ARE PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENCYC ORGANIZATION OR ITS CONTRIBUTORS, OR CYCORP INC. BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE AND KNOWLEDGE BASE CONTENT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

<p>
<!------------------------------------------------------------------------->

<hr><a name="introduction"></a><h1>1. Introduction</h1>

<p>

This document describes the Cyc Application Programmers Interface
(API).  This is the protocol which allows applications to connect to
and use the various CycL modules and functionality which together are
used to maintain the Cyc Knowledge Base.

<p>

The Cyc API is divided into two layers :

<UL>
<LI><A HREF="#content">The Content Layer</A> categorizes the available functions, 
and provides the function signatures and documentation used by applications.  The java CycAccess class contains the majority of these functions for ease of integration.</LI></UL>

<UL>
<LI> <A HREF="#transport">The Transport Layer</A> establishes connection to a
Cyc server and performs the message handling.  The ASCII telnet connection is useful for debugging and remote administration, and the binary CFASL interface is used for applications.  The java CycConnection, CfaslInputStream and CfaslOutputStream classes contain the transport layer functions.</LI></UL>


<!------------------------------------------------------------------------->
<hr><h1><a name="content"></a>2. Content Layer</h1>

<p>

The Content Layer of the Cyc API contains a list of the exposed
functionality provided by the Cyc server.  Each category is
described below, followed by a list of the function signatures and
documentation.

<a HREF="#appendix-a">Appendix A</a>

provides an Index of all functions in the Content Layer.

<p>

Cycorp has implemented the Cyc API in a language it designed called
SubL.  SubL in turn can be easily implemented in both Common Lisp and
C, and can therefore be -- and has been -- ported to many different
platforms and operating systems.  The function and macro signatures
are given in SubL format, which in this case is identical to Common
Lisp format.  For more on SubL, see the

<a HREF="ref/subl-reference.html">SubL Reference</a>

manual.

<!------------------------------------------------------------------------->
<!-- Insert Content Layer section here -->
<h2>Contents<br></h2>

<table cellspacing=2 border= cellpadding=7 width=500>
<tr><td width="12%" valign="TOP" height=13>
<p></td>

<td width="18%" valign="TOP" height=13>
<p><A HREF="#Section-211">2.1.1 </a></td>
<td width="70%" valign="TOP" height=13>
<p><A HREF="#Section-211">Constants</a></td>
</tr>

<tr><td width="12%" valign="TOP" height=13><p></P></td>
<td width="18%" valign="TOP" height=13>
<p><A HREF="#Section-212">2.1.2</a></td>
<td width="70%" valign="TOP" height=13>
<p><A HREF="#Section-212">NATS (Non Atomic Terms)</a></td>
</tr>

<tr><td width="12%" valign="TOP" height=13><p></P></td>
<td width="18%" valign="TOP" height=13>
<p><A HREF="#Section-213">2.1.3</a></td>
<td width="70%" valign="TOP" height=13>
<p><A HREF="#Section-213">FORTS (First Order Reified Terms)</a></td>
</tr>

<tr><td width="12%" valign="TOP" height=13><p></P></td>
<td width="18%" valign="TOP" height=13>
<p><A HREF="#Section-214">2.1.4</a></td>
<td width="70%" valign="TOP" height=13>
<p><A HREF="#Section-214">HL Assertions</a></td>

</tr>
<tr><td width="12%" valign="TOP" height=13><p></P></td>
<td width="18%" valign="TOP" height=13>
<p><A HREF="#Section-215">2.1.5</a></td>
<td width="70%" valign="TOP" height=13>
<p><A HREF="#Section-215">HL Formulas and Clauses</a></td>
</tr>

<tr><td width="12%" valign="TOP" height=13><p></P></td>
<td width="18%" valign="TOP" height=13>
<p><A HREF="#Section-216">2.1.6</a></td>
<td width="70%" valign="TOP" height=13>
<p><A HREF="#Section-216">HL Arguments</a></td>
</tr>

<tr><td width="12%" valign="TOP" height=13><p></P></td>
<td width="18%" valign="TOP" height=13>
<p><A HREF="#Section-217">2.1.7</a></td>
<td width="70%" valign="TOP" height=13>
<p><A HREF="#Section-217">HL Deductions</a></td>
</tr>

<tr><td width="12%" valign="TOP" height=13><p></P></td>
<td width="18%" valign="TOP" height=13>
<p><A HREF="#Section-218">2.1.8</a></td>
<td width="70%" valign="TOP" height=13>
<p><A HREF="#Section-218">HL Supports</a></td>
</tr>

<tr><td width="12%" valign="TOP" height=13><p></P></td>
<td width="18%" valign="TOP" height=13>
<p><A HREF="#Section-219">2.1.9</a></td>
<td width="70%" valign="TOP" height=13>
<p><A HREF="#Section-219">HL Variables</a></td>
</tr>

<tr><td width="12%" valign="TOP" height=13><p></P></td>
<td width="18%" valign="TOP" height=13>
<p><A HREF="#Section-22">2.2</a></td>
<td width="70%" valign="TOP" height=13>
<p><A HREF="#Section-22">KB Indexing</a></td>
</tr>

<tr><td width="12%" valign="TOP" height=13><p></P></td>
<td width="18%" valign="TOP" height=13>
<p><A HREF="#Section-23">2.3</a></td>
<td width="70%" valign="TOP" height=13>
<p><A HREF="#Section-23">KB Mapping</a></td>
</tr>

<tr><td width="12%" valign="TOP" height=13><p></P></td>
<td width="18%" valign="TOP" height=13>
<p><A HREF="#Section-24">2.4</a></td>
<td width="70%" valign="TOP" height=13>
<p><A HREF="#Section-24">KB Accessors</a></td>
</tr>

<tr><td width="12%" valign="TOP" height=13><p></P></td>
<td width="18%" valign="TOP" height=13>
<p><A HREF="#Section-25">2.5</a></td>
<td width="70%" valign="TOP" height=13>
<p><A HREF="#Section-25">Epistemological-Level Support</a></td>
</tr>

<tr><td width="12%" valign="TOP" height=13><p></P></td>
<td width="18%" valign="TOP" height=13>
<p><A HREF="#Section-26">2.6</a></td>
<td width="70%" valign="TOP" height=13>
<p><A HREF="#Section-26">Transitivity HL Modules</a></td>
</tr>

<tr><td width="12%" valign="TOP" height=13><p></P></td>
<td width="18%" valign="TOP" height=13>
<p><A HREF="#Section-261">2.6.1 </a></td>
<td width="70%" valign="TOP" height=13>
<p><A HREF="#Section-261">Subsumption-Based HL Modules</a></td>
</tr>

<tr><td width="12%" valign="TOP" height=13><p></P></td>
<td width="18%" valign="TOP" height=13>
<p><A HREF="#Section-2611">2.6.1.1</a></td>
<td width="70%" valign="TOP" height=13>
<p><A HREF="#Section-2611">#$isa support</a></td>
</tr>

<tr><td width="12%" valign="TOP" height=13><p></P></td>
<td width="18%" valign="TOP" height=13>
<p><A HREF="#Section-2612">2.6.1.2</a></td>
<td width="70%" valign="TOP" height=13>
<p><A HREF="#Section-2612">#$genls support</a></td>
</tr>

<tr><td width="12%" valign="TOP" height=13><p></P></td>
<td width="18%" valign="TOP" height=13>
<p><A HREF="#Section-2613">2.6.1.3</a></td>
<td width="70%" valign="TOP" height=13>
<p><A HREF="#Section-2613">#$genlPreds and #$genlInverse support</a></td>
</tr>

<tr><td width="12%" valign="TOP" height=13><p></P></td>
<td width="18%" valign="TOP" height=13>
<p><A HREF="#Section-2614">2.6.1.4</a></td>
<td width="70%" valign="TOP" height=13>
<p><A HREF="#Section-2614">General Transitivity support</a></td>
</tr>

<tr><td width="12%" valign="TOP" height=13><p></P></td>
<td width="18%" valign="TOP" height=13>
<p><A HREF="#Section-2615">2.6.1.5</a></td>
<td width="70%" valign="TOP" height=13>
<p><A HREF="#Section-2615">#$genlAttributes support</a></td>
</tr>

<tr><td width="12%" valign="TOP" height=13><p></P></td>
<td width="18%" valign="TOP" height=13>
<p><A HREF="#Section-27">2.7</a></td>
<td width="70%" valign="TOP" height=13>
<p><A HREF="#Section-27">Inference Module</a></td>
</tr>


<tr><td width="12%" valign="TOP" height=13><p></P></td>
<td width="18%" valign="TOP" height=13><p></P></td>
<td width="70%" valign="TOP" height=13>
<p><A HREF="#appendix-a">Appendix A : Glossary</a></td>
</tr>

<tr><td width="12%" valign="TOP" height=13><p></P></td>
<td width="18%" valign="TOP" height=13><p></P></td>
<td width="70%" valign="TOP" height=13>
<p><A HREF="#appendix-b">Appendix B : Index</a></td>
</tr>
</table>


<h2>2.1 KB representation</h2>
<p>

Methods for directly manipulating KB datastructures

<a name="Section-211"></a><h3>2.1.1 Constants</h3>
<no-newlines>
<a name="FN-DEF-CONSTANT-P"></a>function <tt><b>CONSTANT-P</b> : (object)</tt><br>
Return T iff the argument is a CycL constant<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-CONSTANT-EXTERNAL-ID"></a>function <tt><b>CONSTANT-EXTERNAL-ID</b> : (constant)</tt><br>
Return the external id of CONSTANT.<br>
 CONSTANT must satisfy CONSTANT-P.<br>
Single value returned satisfies CONSTANT-EXTERNAL-ID-P or is NIL.<fn-def>
<br>
<br>
<a name="FN-DEF-CONSTANT-INTERNAL-ID"></a>function <tt><b>CONSTANT-INTERNAL-ID</b> : (constant)</tt><br>
Return the internal id of CONSTANT.<br>
 CONSTANT must satisfy CONSTANT-P.<br>
Single value returned satisfies CONSTANT-INTERNAL-ID-P or is NIL.<fn-def>
<br>
<br>
<a name="FN-DEF-CONSTANT-NAME"></a>function <tt><b>CONSTANT-NAME</b> : (constant)</tt><br>
Return the name of CONSTANT or :unnamed.<br>
 CONSTANT must satisfy CONSTANT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-FIND-CONSTANT"></a>function <tt><b>FIND-CONSTANT</b> : (name)</tt><br>
Return the constant with NAME, or NIL if not present.<br>
 NAME must satisfy STRINGP.<br>
Single value returned satisfies CONSTANT-P or is NIL.<fn-def>
<br>
<br>
<a name="FN-DEF-FIND-CONSTANT-BY-EXTERNAL-ID"></a>function <tt><b>FIND-CONSTANT-BY-EXTERNAL-ID</b> : (external-id)</tt><br>
Return the constant with EXTERNAL-ID, or NIL if not present.<br>
 EXTERNAL-ID must satisfy CONSTANT-EXTERNAL-ID-P.<br>
Single value returned satisfies CONSTANT-P or is NIL.<fn-def>
<br>
<br>
<a name="FN-DEF-FIND-CONSTANT-BY-INTERNAL-ID"></a>function <tt><b>FIND-CONSTANT-BY-INTERNAL-ID</b> : (id)</tt><br>
Return the constant with internal ID, or NIL if not present.<br>
 ID must satisfy CONSTANT-INTERNAL-ID-P.<br>
Single value returned satisfies CONSTANT-P or is NIL.<fn-def>
<br>
<br>
<a name="FN-DEF-CREATE-CONSTANT"></a>function <tt><b>CREATE-CONSTANT</b> : (name &amp;optional external-id)</tt><br>
Return a new constant named NAME.  Use EXTERNAL-ID if non-null, else create a new ID.<br>
Single value returned  satisfies CONSTANT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-FIND-OR-CREATE-CONSTANT"></a>function <tt><b>FIND-OR-CREATE-CONSTANT</b> : (name &amp;optional external-id)</tt><br>
Return the constant with NAME if it exists, otherwise create it with EXTERNAL-ID.<br>
<code>  </code>Also, if it exists but has a null id, install EXTERNAL-ID on the constant.<br>
 NAME must satisfy STRINGP.<br>
Single value returned  satisfies CONSTANT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-RENAME-CONSTANT"></a>function <tt><b>RENAME-CONSTANT</b> : (constant new-name)</tt><br>
Rename CONSTANT to have NEW-NAME as its name.  The constant is returned.<br>
 CONSTANT must satisfy CONSTANT-P.<br>
 NEW-NAME must satisfy STRINGP.<br>
Single value returned  satisfies CONSTANT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-UNIQUIFY-CONSTANT-NAME"></a>function <tt><b>UNIQUIFY-CONSTANT-NAME</b> : (name)</tt><br>
Return a unique, currently unused constant name based on NAME, which must be a valid constant name.<br>
 NAME must satisfy STRINGP.<br>
Single value returned  satisfies STRINGP.<fn-def>
<br>
<br>
<a name="FN-DEF-REMOVE-CONSTANT"></a>function <tt><b>REMOVE-CONSTANT</b> : (constant)</tt><br>
Remove constant from the KB.<br>
 CONSTANT must satisfy CONSTANT-P.<br>
Single value returned  satisfies NULL.<fn-def>
<br>
<br>
<a name="FN-DEF-DO-CONSTANTS"></a>macro <tt><b>DO-CONSTANTS</b> : ((var &amp;optional (message "mapping Cyc constants")) &amp;body body)</tt><br>
Iterate over all HL constant datastructures, executing BODY within the scope of VAR.<br>
VAR is bound to each constant in turn.<br>
MESSAGE is a progress message string.<fn-def>
<br>
<br>
<a name="FN-DEF-CONSTANT-COUNT"></a>function <tt><b>CONSTANT-COUNT</b> : ()</tt><br>
Return the total number of constants.<br>
Single value returned  satisfies INTEGERP.<fn-def>
<br>
<br>
<a name="FN-DEF-VALID-CONSTANT-NAME-CHAR"></a>function <tt><b>VALID-CONSTANT-NAME-CHAR</b> : (char)</tt><br>
Return T iff CHAR is a character which is allowed in a valid constant name.<br>
 CHAR must satisfy CHARACTERP.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-VALID-CONSTANT-NAME"></a>function <tt><b>VALID-CONSTANT-NAME</b> : (string)</tt><br>
Return T iff STRING is a valid name for a constant.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-CONSTANT-COMPLETE-EXACT"></a>function <tt><b>CONSTANT-COMPLETE-EXACT</b> : (string &amp;optional start end)</tt><br>
Return a valid constant whose name exactly matches STRING.<br>
Optionally the START and END character positions can be<br>
specified, such that the STRING matches characters between the START and <br>
END range.  If no constant exists, return NIL.<br>
 STRING must satisfy STRINGP.<br>
 START must satisfy FIXNUMP.<fn-def>
<br>
<br>
<a name="FN-DEF-CONSTANT-COMPLETE"></a>function <tt><b>CONSTANT-COMPLETE</b> : (prefix &amp;optional case-sensitive? exact-length? start end)</tt><br>
Return all valid constants with PREFIX as a prefix of their name<br>
When CASE-SENSITIVE? is non-nil, the comparison is done in a case-sensitive fashion.<br>
When EXACT-LENGTH? is non-nil, the prefix must be the entire string<br>
Optionally the START and END character positions can be<br>
specified, such that the PREFIX matches characters between the START and <br>
END range.  If no constant exists, return NIL.<br>
 PREFIX must satisfy STRINGP.<br>
 CASE-SENSITIVE? must satisfy BOOLEANP.<br>
 EXACT-LENGTH? must satisfy BOOLEANP.<br>
 START must satisfy FIXNUMP.<fn-def>
<br>
<br>
<a name="FN-DEF-CONSTANT-APROPOS"></a>function <tt><b>CONSTANT-APROPOS</b> : (substring &amp;optional case-sensitive? start end)</tt><br>
Return all valid constants with SUBSTRING somewhere in their name<br>
When CASE-SENSITIVE? is non-nil, the comparison is done in a case-sensitive fashion.<br>
Optionally the START and END character positions can be<br>
specified, such that the SUBSTRING matches characters between the START and <br>
END range.  If no constant exists, return NIL.<br>
 SUBSTRING must satisfy STRINGP.<br>
 CASE-SENSITIVE? must satisfy BOOLEANP.<br>
 START must satisfy FIXNUMP.<fn-def>

<a name="Section-212"></a><h3>2.1.2 NARTS (Non Atomic Reified Terms)</h3>
<no-newlines>
<a name="FN-DEF-NART-P"></a>function <tt><b>NART-P</b> : (object)</tt><br>
Return T iff OBJECT is a datastructure implementing a non-atomic reified term (NART).<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-NART-ID"></a>function <tt><b>NART-ID</b> : (nart)</tt><br>
Return the id of this NART.<br>
 NART must satisfy NART-P.<br>
Single value returned  satisfies INTEGERP.<fn-def>
<br>
<br>
<a name="FN-DEF-FIND-NART-BY-ID"></a>function <tt><b>FIND-NART-BY-ID</b> : (id)</tt><br>
Return the NART with ID, or NIL if not present.<br>
 ID must satisfy INTEGERP.<br>
Single value returned satisfies NART-P or is NIL.<fn-def>
<br>
<br>
<a name="FN-DEF-NART-HL-FORMULA"></a>function <tt><b>NART-HL-FORMULA</b> : (nart)</tt><br>
Return the hl formula of this NART.<br>
 NART must satisfy NART-P.<br>
Single value returned satisfies CONSP or is NIL.<fn-def>
<br>
<br>
<a name="FN-DEF-NART-EL-FORMULA"></a>function <tt><b>NART-EL-FORMULA</b> : (nart)</tt><br>
Return the el formula of this NART.<br>
 NART must satisfy NART-P.<br>
Single value returned satisfies CONSP or is NIL.<fn-def>
<br>
<br>
<a name="FN-DEF-REMOVE-NART"></a>function <tt><b>REMOVE-NART</b> : (nart)</tt><br>
Remove NART from the KB.<br>
 NART must satisfy NART-P.<br>
Single value returned  satisfies NULL.<fn-def>
<br>
<br>
<a name="FN-DEF-NART-COUNT"></a>function <tt><b>NART-COUNT</b> : ()</tt><br>
Return the total number of NARTs.<br>
Single value returned  satisfies INTEGERP.<fn-def>
<br>
<br>
<a name="FN-DEF-DO-NARTS"></a>macro <tt><b>DO-NARTS</b> : ((var &amp;optional (message "mapping Cyc NARTs")) &amp;body body)</tt><br>
Iterate over all HL NART datastructures, executing BODY within the scope of VAR.<br>
VAR is bound to the NART.<br>
MESSAGE is a progress message string.<fn-def>

<a name="Section-213"></a><h3>2.1.3 FORTS</h3>
<no-newlines>
<a name="FN-DEF-FORT-P"></a>function <tt><b>FORT-P</b> : (object)</tt><br>
Return T iff OBJECT is a first order reified term (FORT).<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-EL-FORT-P"></a>function <tt><b>EL-FORT-P</b> : (object)</tt><br>
Returns t iff OBJECT is a fort or an EL formula.<br>
Single value returned  satisfies BOOLEANP.<fn-def>  
<br>
<br>
<a name="FN-DEF-FORT-EL-FORMULA"></a>function <tt><b>FORT-EL-FORMULA</b> : (fort)</tt><br>
Return the EL formula for any FORT.<br>
 FORT must satisfy FORT-P.<br>
Single value returned satisfies CONSP or is NIL.<fn-def>
<br>
<br>
<a name="FN-DEF-REMOVE-FORT"></a>function <tt><b>REMOVE-FORT</b> : (fort)</tt><br>
Remove FORT from the KB.<br>
 FORT must satisfy FORT-P.<br>
Single value returned  satisfies NULL.<fn-def>
<br>
<br>
<a name="FN-DEF-FORT-COUNT"></a>function <tt><b>FORT-COUNT</b> : ()</tt><br>
Return the total number of FORTs.<br>
Single value returned  satisfies INTEGERP.<fn-def>
<br>
<br>
<a name="FN-DEF-DO-FORTS"></a>macro <tt><b>DO-FORTS</b> : ((var &amp;optional (message "mapping Cyc FORTs")) &amp;body body)</tt><br>
Iterate over all HL FORT datastructures, executing BODY within the scope of VAR.<br>
VAR is bound to the FORT.<br>
MESSAGE is a progress message string.<fn-def>

<a name="Section-214"></a><h3>2.1.4 HL Assertions</h3>
<no-newlines>
<a name="FN-DEF-ASSERTION-P"></a>function <tt><b>ASSERTION-P</b> : (object)</tt><br>
Return T iff OBJECT is an HL assertion<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-ASSERTION-ID"></a>function <tt><b>ASSERTION-ID</b> : (assertion)</tt><br>
Return the id of this ASSERTION.<br>
 ASSERTION must satisfy ASSERTION-P.<br>
Single value returned  satisfies INTEGERP.<fn-def>
<br>
<br>
<a name="FN-DEF-ASSERTION-CNF"></a>function <tt><b>ASSERTION-CNF</b> : (assertion)</tt><br>
Return the cnf of ASSERTION.<br>
<code>   </code>@note If you know the assertion is a gaf,<br>
<code>   </code>consider using gaf-formula instead,<br>
<code>   </code>if you do not explicitly need a CNF.<br>
 ASSERTION must satisfy ASSERTION-P.<br>
Single value returned  satisfies CNF-P.<fn-def>
<br>
<br>
<a name="FN-DEF-ASSERTION-FORMULA"></a>function <tt><b>ASSERTION-FORMULA</b> : (assertion)</tt><br>
Return a formula for ASSERTION.<br>
 ASSERTION must satisfy ASSERTION-P.<br>
Single value returned  satisfies EL-FORMULA-P.<fn-def>
<br>
<br>
<a name="FN-DEF-ASSERTION-IST-FORMULA"></a>function <tt><b>ASSERTION-IST-FORMULA</b> : (assertion)</tt><br>
Return a formula in #$ist format for ASSERTION.<br>
 ASSERTION must satisfy ASSERTION-P.<br>
Single value returned  satisfies EL-FORMULA-P.<fn-def>
<br>
<br>
<a name="FN-DEF-ASSERTION-MENTIONS-TERM"></a>function <tt><b>ASSERTION-MENTIONS-TERM</b> : (assertion term)</tt><br>
Return T iff ASSERTION's formula or mt contains TERM.<br>
<code>   </code>If assertion is a meta-assertion, recurse down sub-assertions.<br>
<code>   </code>By convention, negated gafs do not necessarily mention the term #$not.<br>
 ASSERTION must satisfy ASSERTION-P.<br>
 TERM must satisfy HL-TERM-P.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-ASSERTION-MT"></a>function <tt><b>ASSERTION-MT</b> : (assertion)</tt><br>
Return the mt of ASSERTION.<br>
 ASSERTION must satisfy ASSERTION-P.<br>
Single value returned  satisfies FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-ASSERTION-DIRECTION"></a>function <tt><b>ASSERTION-DIRECTION</b> : (assertion)</tt><br>
Return the direction of ASSERTION (either :backward, :forward or :code).<br>
 ASSERTION must satisfy ASSERTION-P.<br>
Single value returned  satisfies DIRECTION-P.<fn-def>
<br>
<br>
<a name="FN-DEF-FORWARD-ASSERTION?"></a>function <tt><b>FORWARD-ASSERTION?</b> : (assertion)</tt><br>
Predicate returns T iff ASSERTION's direction is :FORWARD.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-BACKWARD-ASSERTION?"></a>function <tt><b>BACKWARD-ASSERTION?</b> : (assertion)</tt><br>
Predicate returns T iff ASSERTION's direction is :BACKWARD.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-DIRECTION-P"></a>function <tt><b>DIRECTION-P</b> : (object)</tt><br>
Return T iff OBJECT is a valid assertion inference direction<br>
<code> </code>:backward :forward or :code.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-CODE-ASSERTION?"></a>function <tt><b>CODE-ASSERTION?</b> : (assertion)</tt><br>
Predicate returns T iff ASSERTION's direction is :CODE.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-ASSERTION-TRUTH"></a>function <tt><b>ASSERTION-TRUTH</b> : (assertion)</tt><br>
Return the current truth of ASSERTION -- either :true :false or :unknown.<br>
 ASSERTION must satisfy ASSERTION-P.<br>
Single value returned  satisfies TRUTH-P.<fn-def>
<br>
<br>
<a name="FN-DEF-ASSERTION-HAS-TRUTH"></a>function <tt><b>ASSERTION-HAS-TRUTH</b> : (assertion truth)</tt><br>
Return T iff ASSERTION's current truth is TRUTH.<br>
 ASSERTION must satisfy ASSERTION-P.<br>
 TRUTH must satisfy TRUTH-P.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-TRUTH-P"></a>function <tt><b>TRUTH-P</b> : (object)</tt><br>
Returns T iff OBJECT is a valid CycL truth<br>
<code> </code>:true :false or :unknown.<fn-def>
<br>
<br>
<a name="FN-DEF-ASSERTION-STRENGTH"></a>function <tt><b>ASSERTION-STRENGTH</b> : (assertion)</tt><br>
Return the current argumentation strength of ASSERTION -- either :monotonic :default or :unknown.<br>
 ASSERTION must satisfy ASSERTION-P.<br>
Single value returned  satisfies EL-STRENGTH-P.<fn-def>
<br>
<br>
<a name="FN-DEF-ASSERTION-HAS-META-ASSERTIONS?"></a>function <tt><b>ASSERTION-HAS-META-ASSERTIONS?</b> : (assertion)</tt><br>
Return T iff ASSERTION has some meta-assertions.<br>
 ASSERTION must satisfy ASSERTION-P.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-FIND-ASSERTION-BY-ID"></a>function <tt><b>FIND-ASSERTION-BY-ID</b> : (id)</tt><br>
Return the assertion with ID, or NIL if not present.<br>
 ID must satisfy INTEGERP.<br>
Single value returned satisfies ASSERTION-P or is NIL.<fn-def>
<br>
<br>
<a name="FN-DEF-FIND-ASSERTION"></a>function <tt><b>FIND-ASSERTION</b> : (cnf mt)</tt><br>
Find the assertion in MT with CNF.  Return NIL if not present.<br>
 CNF must satisfy CNF-P.<br>
 MT must satisfy FORT-P.<br>
Single value returned satisfies ASSERTION-P or is NIL.<fn-def>
<br>
<br>
<a name="FN-DEF-FIND-ASSERTION-ANY-MT"></a>function <tt><b>FIND-ASSERTION-ANY-MT</b> : (cnf)</tt><br>
Find any assertion in any mt with CNF.  Return NIL if none are present.<br>
 CNF must satisfy CNF-P.<br>
Single value returned satisfies ASSERTION-P or is NIL.<fn-def>
<br>
<br>
<a name="FN-DEF-FIND-ALL-ASSERTIONS"></a>function <tt><b>FIND-ALL-ASSERTIONS</b> : (cnf)</tt><br>
Return all assertions that have CNF or NIL if there aren't any.<br>
 CNF must satisfy CNF-P.<br>
Single value returned satisfies (LIST ASSERTION-P) or is NIL.<fn-def>
<br>
<br>
<a name="FN-DEF-FIND-GAF"></a>function <tt><b>FIND-GAF</b> : (gaf mt)</tt><br>
Find the assertion in MT with GAF as its formula.  Return NIL if not present.<br>
 GAF must satisfy EL-FORMULA-P.<br>
 MT must satisfy FORT-P.<br>
Single value returned satisfies ASSERTION-P or is NIL.<fn-def>
<br>
<br>
<a name="FN-DEF-FIND-GAF-ANY-MT"></a>function <tt><b>FIND-GAF-ANY-MT</b> : (gaf)</tt><br>
Find any assertion in any mt with GAF as its formula.  Return NIL if not present.<br>
 GAF must satisfy EL-FORMULA-P.<br>
Single value returned satisfies ASSERTION-P or is NIL.<fn-def>
<br>
<br>
<a name="FN-DEF-FIND-ALL-GAFS"></a>function <tt><b>FIND-ALL-GAFS</b> : (gaf)</tt><br>
Return all assertions of GAF or NIL if there aren't any.<br>
 GAF must satisfy EL-FORMULA-P.<br>
Single value returned satisfies (LIST ASSERTION-P) or is NIL.<fn-def>
<br>
<br>
<a name="FN-DEF-GET-ASSERTED-ARGUMENT"></a>function <tt><b>GET-ASSERTED-ARGUMENT</b> : (assertion)</tt><br>
Return the asserted argument for ASSERTION, or nil if none present.<br>
 ASSERTION must satisfy ASSERTION-P.<br>
Single value returned satisfies ASSERTED-ARGUMENT-P or is NIL.<fn-def>
<br>
<br>
<a name="FN-DEF-ASSERTED-ASSERTION?"></a>function <tt><b>ASSERTED-ASSERTION?</b> : (assertion)</tt><br>
Return non-nil IFF assertion has an asserted argument.<br>
 ASSERTION must satisfy ASSERTION-P.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-DEDUCED-ASSERTION?"></a>function <tt><b>DEDUCED-ASSERTION?</b> : (assertion)</tt><br>
Return non-nil IFF assertion has some deduced argument<br>
 ASSERTION must satisfy ASSERTION-P.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-ASSERTION-EL-IST-FORMULA"></a>function <tt><b>ASSERTION-EL-IST-FORMULA</b> : (assertion)</tt><br>
Return the el formula in #$ist format for ASSERTION.<br>
 ASSERTION must satisfy ASSERTION-P.<br>
Single value returned  satisfies CONSP.<fn-def> 
<br>
<br>
<a name="FN-DEF-ASSERTION-HAS-DEPENDENTS-P"></a>function <tt><b>ASSERTION-HAS-DEPENDENTS-P</b> : (assertion)</tt><br>
Return non-nil IFF assertion has dependents.<br>
 ASSERTION must satisfy ASSERTION-P.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-DO-ASSERTIONS"></a>macro <tt><b>DO-ASSERTIONS</b> : ((var &amp;optional (message "mapping Cyc assertions")) &amp;body body)</tt><br>
Iterate over all HL assertion datastructures, executing BODY within the scope of VAR.<br>
VAR is bound to the assertion.<br>
MESSAGE is a progress message string.<fn-def>
<br>
<br>
<a name="FN-DEF-ASSERTION-COUNT"></a>function <tt><b>ASSERTION-COUNT</b> : ()</tt><br>
Return the total number of assertions.<br>
Single value returned  satisfies INTEGERP.<fn-def>

<a name="Section-215"></a><h3>2.1.5 HL Formulas and Clauses</h3>
<no-newlines>
<a name="FN-DEF-NEGATED?"></a>function <tt><b>NEGATED?</b> : (form)</tt><br>
Assuming FORM is a valid CycL formula, return T IFF it is negated.<br>
 FORM must satisfy EL-FORMULA-P.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-NEGATE"></a>function <tt><b>NEGATE</b> : (form)</tt><br>
Assuming FORM is a valid CycL formula, return a negated version of it.<br>
 FORM must satisfy EL-FORMULA-P.<br>
Single value returned  satisfies EL-FORMULA-P.<fn-def>
<br>
<br>
<a name="FN-DEF-CLAUSE-P"></a>function <tt><b>CLAUSE-P</b> : (object)</tt><br>
Returns T iff OBJECT is either a CNF or DNF clause.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-SENSE-P"></a>function <tt><b>SENSE-P</b> : (object)</tt><br>
Return T iff OBJECT is a valid CycL literal sense<br>
<code> </code>:neg or :pos.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-MAKE-CLAUSE"></a>function <tt><b>MAKE-CLAUSE</b> : (neg-lits pos-lits)</tt><br>
Construct a clause from NEG-LITS and POS-LITS, each of which are lists of literals.<br>
 NEG-LITS must satisfy LISTP.<br>
 POS-LITS must satisfy LISTP.<br>
Single value returned  satisfies CLAUSE-P.<fn-def>
<br>
<br>
<a name="FN-DEF-NEG-LITS"></a>function <tt><b>NEG-LITS</b> : (clause)</tt><br>
Return the neg-lits of CLAUSE.<br>
 CLAUSE must satisfy CLAUSE-P.<br>
Single value returned  satisfies LISTP.<fn-def>
<br>
<br>
<a name="FN-DEF-POS-LITS"></a>function <tt><b>POS-LITS</b> : (clause)</tt><br>
Return the pos-lits of CLAUSE.<br>
 CLAUSE must satisfy CLAUSE-P.<br>
Single value returned  satisfies LISTP.<fn-def>
<br>
<br>
<a name="FN-DEF-CLAUSE-EQUAL"></a>function <tt><b>CLAUSE-EQUAL</b> : (clause1 clause2)</tt><br>
Return T iff CLAUSE1 and CLAUSE2 are both equivalent clauses.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-EMPTY-CLAUSE"></a>function <tt><b>EMPTY-CLAUSE</b> : ()</tt><br>
Return the empty clause.<br>
Single value returned  satisfies CLAUSE-P.<fn-def>
<br>
<br>
<a name="FN-DEF-EMPTY-CLAUSE?"></a>function <tt><b>EMPTY-CLAUSE?</b> : (clause)</tt><br>
Return T iff CLAUSE is empty.<br>
 CLAUSE must satisfy CLAUSE-P.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-CLAUSE-LITERAL"></a>function <tt><b>CLAUSE-LITERAL</b> : (clause sense num)</tt><br>
Return literal in CLAUSE specified by SENSE and NUM.<br>
<code>  </code>SENSE must be either :pos or :neg.<br>
 CLAUSE must satisfy CLAUSE-P.<br>
 SENSE must satisfy SENSE-P.<br>
 NUM must satisfy INTEGERP.<fn-def>
<br>
<br>
<a name="FN-DEF-CLAUSE-WITHOUT-LITERAL"></a>function <tt><b>CLAUSE-WITHOUT-LITERAL</b> : (clause sense num)</tt><br>
Return a new clause which is CLAUSE without the literal specified by SENSE and NUM.<br>
<code>  </code>SENSE must be either :pos or :neg.<br>
 CLAUSE must satisfy CLAUSE-P.<br>
 SENSE must satisfy SENSE-P.<br>
 NUM must satisfy INTEGERP.<br>
Single value returned  satisfies CLAUSE-P.<fn-def>
<br>
<br>
<a name="FN-DEF-GROUND-CLAUSE-P"></a>function <tt><b>GROUND-CLAUSE-P</b> : (clause)</tt><br>
Return T iff CLAUSE is a ground clause.<br>
Single value returned  satisfies BOOLEANP.<fn-def> 
<br>
<br>
<a name="FN-DEF-CNF-P"></a>function <tt><b>CNF-P</b> : (object)</tt><br>
Returns T iff OBJECT is a canonicalized CycL formula in conjunctive normal form.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-GAF-CNF?"></a>function <tt><b>GAF-CNF?</b> : (cnf)</tt><br>
Return T iff CNF is a cnf representation of a gaf formula.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-CNF-FORMULA"></a>function <tt><b>CNF-FORMULA</b> : (cnf &amp;optional truth)</tt><br>
Return a readable formula of CNF<br>
<code>   </code>TRUTH only gets looked at for ground, single pos lit cnfs<br>
<code>   </code>in which case TRUTH gives the truth of the gaf.<br>
 CNF must satisfy CNF-P.<br>
 TRUTH must satisfy TRUTH-P.<br>
Single value returned  satisfies EL-FORMULA-P.<fn-def>
<br>
<br>
<a name="FN-DEF-CNF-FORMULA-FROM-CLAUSES"></a>function <tt><b>CNF-FORMULA-FROM-CLAUSES</b> : (cnf-clauses)</tt><br>
Return a readable formula from a list of CNF-CLAUSES.<br>
 CNF-CLAUSES must satisfy LISTP.<br>
Single value returned  satisfies EL-FORMULA-P.<fn-def>
<br>
<br>
<a name="FN-DEF-DNF-FORMULA"></a>function <tt><b>DNF-FORMULA</b> : (dnf)</tt><br>
Return a readable formula of DNF.<br>
Single value returned  satisfies EL-FORMULA-P.<fn-def>
<br>
<br>
<a name="FN-DEF-DNF-FORMULA-FROM-CLAUSES"></a>function <tt><b>DNF-FORMULA-FROM-CLAUSES</b> : (dnf-clauses)</tt><br>
Return a readable formula from a list of DNF-CLAUSES.<br>
 DNF-CLAUSES must satisfy LISTP.<br>
Single value returned  satisfies EL-FORMULA-P.<fn-def>
<br>
<br>
<a name="FN-DEF-ATOMIC-CLAUSE-P"></a>function <tt><b>ATOMIC-CLAUSE-P</b> : (clause)</tt><br>
Return T iff CLAUSE is an atomic clause.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-HL-TERM-P"></a>function <tt><b>HL-TERM-P</b> : (obj)</tt><br>
Returns T if the OBJ is a valid CycL HL term.<br>
Single value returned  satisfies BOOLEANP.<fn-def>

<a name="Section-216"></a><h3>2.1.6 HL Arguments</h3>
<no-newlines>
<a name="FN-DEF-HL-MODULE-P"></a>function <tt><b>HL-MODULE-P</b> : (object)</tt><br>
Return T iff OBJECT is an HL module.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-ARGUMENT-P"></a>function <tt><b>ARGUMENT-P</b> : (object)</tt><br>
Return T iff OBJECT is an HL argument structure.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-ASSERTED-ARGUMENT-P"></a>function <tt><b>ASSERTED-ARGUMENT-P</b> : (object)</tt><br>
Return T iff OBJECT is an HL asserted argument structure.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-ARGUMENT-EQUAL"></a>function <tt><b>ARGUMENT-EQUAL</b> : (argument1 argument2)</tt><br>
Return T iff ARGUMENT1 and ARGUMENT2 are equivalent arguments.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-ARGUMENT-TRUTH"></a>function <tt><b>ARGUMENT-TRUTH</b> : (argument)</tt><br>
Return the truth of ARGUMENT.<br>
 ARGUMENT must satisfy ARGUMENT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-ARGUMENT-STRENGTH"></a>function <tt><b>ARGUMENT-STRENGTH</b> : (argument)</tt><br>
Return the strength of ARGUMENT.<br>
 ARGUMENT must satisfy ARGUMENT-P.<fn-def>

<a name="Section-217"></a><h3>2.1.7 HL Deductions</h3>
<no-newlines>
<a name="FN-DEF-DEDUCTION-P"></a>function <tt><b>DEDUCTION-P</b> : (object)</tt><br>
Return T iff OBJECT is a CycL deduction.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-DEDUCTION-ID"></a>function <tt><b>DEDUCTION-ID</b> : (deduction)</tt><br>
Return the id of DEDUCTION.<br>
 DEDUCTION must satisfy DEDUCTION-P.<br>
Single value returned  satisfies INTEGERP.<fn-def>
<br>
<br>
<a name="FN-DEF-FIND-DEDUCTION-BY-ID"></a>function <tt><b>FIND-DEDUCTION-BY-ID</b> : (id)</tt><br>
Return the deduction with ID, or NIL if not present.<br>
 ID must satisfy INTEGERP.<br>
Single value returned satisfies DEDUCTION-P or is NIL.<fn-def>
<br>
<br>
<a name="FN-DEF-DEDUCTION-ASSERTION"></a>function <tt><b>DEDUCTION-ASSERTION</b> : (deduction)</tt><br>
Return the assertion for which DEDUCTION is a deduction.<br>
 DEDUCTION must satisfy DEDUCTION-P.<br>
Single value returned  satisfies ASSERTION-P.<fn-def>
<br>
<br>
<a name="FN-DEF-DEDUCTION-COUNT"></a>function <tt><b>DEDUCTION-COUNT</b> : ()</tt><br>
Return the total number of deductions.<br>
Single value returned  satisfies INTEGERP.<fn-def>
<br>
<br>
<a name="FN-DEF-DO-DEDUCTIONS"></a>macro <tt><b>DO-DEDUCTIONS</b> : ((var &amp;optional (message "mapping Cyc deductions")) &amp;body body)</tt><br>
Iterate over all HL deduction datastructures, executing BODY within the scope of VAR.<br>
VAR is a deduction.<br>
MESSAGE is a progress message string.<fn-def>

<a name="Section-218"></a><h3>2.1.8 HL Supports</h3>
<no-newlines>
<a name="FN-DEF-SUPPORT-P"></a>function <tt><b>SUPPORT-P</b> : (object)</tt><br>
Return T iff OBJECT can be a support in an argument.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-SUPPORT-MODULE"></a>function <tt><b>SUPPORT-MODULE</b> : (support)</tt><br>
Return the module of SUPPORT.<br>
 SUPPORT must satisfy SUPPORT-P.<br>
Single value returned  satisfies HL-MODULE-P.<fn-def>
<br>
<br>
<a name="FN-DEF-SUPPORT-MT"></a>function <tt><b>SUPPORT-MT</b> : (support)</tt><br>
Return the microtheory of SUPPORT.<br>
 SUPPORT must satisfy SUPPORT-P.<br>
Single value returned  satisfies FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-SUPPORT-TRUTH"></a>function <tt><b>SUPPORT-TRUTH</b> : (support)</tt><br>
Return the truth of SUPPORT.<br>
 SUPPORT must satisfy SUPPORT-P.<br>
Single value returned  satisfies TRUTH-P.<fn-def>
<br>
<br>
<a name="FN-DEF-SUPPORT-STRENGTH"></a>function <tt><b>SUPPORT-STRENGTH</b> : (support)</tt><br>
Return the strength of SUPPORT.<br>
 SUPPORT must satisfy SUPPORT-P.<br>
Single value returned  satisfies EL-STRENGTH-P.<fn-def>
<br>
<br>
<a name="FN-DEF-SUPPORT-SENTENCE"></a>function <tt><b>SUPPORT-SENTENCE</b> : (support)</tt><br>
Return the sentence of SUPPORT.<br>
 SUPPORT must satisfy SUPPORT-P.<br>
Single value returned  satisfies CONSP.<fn-def> 
<br>
<br>
<a name="FN-DEF-HL-SUPPORT-P"></a>function <tt><b>HL-SUPPORT-P</b> : (object)</tt><br>
Does OBJECT represent an HL support?<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-MAKE-HL-SUPPORT"></a>function <tt><b>MAKE-HL-SUPPORT</b> : (hl-module sentence &amp;optional mt tv)</tt><br>
Construct a new HL support.<br>
 HL-MODULE must satisfy HL-MODULE-P.<br>
 SENTENCE must satisfy POSSIBLY-SENTENCE-P.<br>
 MT must satisfy FORT-P.<br>
 TV must satisfy TV-P.<br>
Single value returned  satisfies HL-SUPPORT-P.<fn-def>

<a name="Section-219"></a><h3>2.1.9 HL Variables</h3>
<no-newlines>
<a name="FN-DEF-EL-VAR?"></a>function <tt><b>EL-VAR?</b> : (object)</tt><br>
Return T iff OBJECT is a symbol which can be interpreted as an EL variable.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-VARIABLE-P"></a>function <tt><b>VARIABLE-P</b> : (object)</tt><br>
Return T iff OBJECT is an HL variable.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-FIND-VARIABLE-BY-ID"></a>function <tt><b>FIND-VARIABLE-BY-ID</b> : (id)</tt><br>
Return the HL variable with ID, or NIL if not present.<br>
 ID must satisfy INTEGERP.<br>
Single value returned satisfies VARIABLE-P or is NIL.<fn-def>
<br>
<br>
<a name="FN-DEF-VARIABLE-ID"></a>function <tt><b>VARIABLE-ID</b> : (variable)</tt><br>
Return id of HL variable VARIABLE.<br>
 VARIABLE must satisfy VARIABLE-P.<br>
Single value returned  satisfies INTEGERP.<fn-def> 
<br>
<br>
<a name="FN-DEF-DEFAULT-EL-VAR-FOR-HL-VAR"></a>function <tt><b>DEFAULT-EL-VAR-FOR-HL-VAR</b> : (variable)</tt><br>
Return a readable EL var from HL var VARIABLE.<br>
 VARIABLE must satisfy VARIABLE-P.<fn-def>
<br>
<br>
<a name="FN-DEF-FULLY-BOUND-P"></a>function <tt><b>FULLY-BOUND-P</b> : (object)</tt><br>
Return T iff OBJECT contains no HL variables, and therefore is fully bound.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-VARIABLE-COUNT"></a>function <tt><b>VARIABLE-COUNT</b> : ()</tt><br>
Return the total number of HL variables.<br>
Single value returned  satisfies INTEGERP.<fn-def> 


<a name="Section-22"></a><h2>2.2 KB Indexing</h2>
<p>

Methods for querying the structures used to index assertions from constants.

<br>
<br>
<a name="FN-DEF-INDEXED-TERM-P"></a>function <tt><b>INDEXED-TERM-P</b> : (object)</tt><br>
Returns T iff OBJECT is an indexed CycL term, i.e. a fort or an assertion.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-REMOVE-TERM-INDICES"></a>function <tt><b>REMOVE-TERM-INDICES</b> : (term)</tt><br>
Remove all assertions about TERM from the KB. Return the TERM.<br>
Single value returned  satisfies INDEXED-TERM-P.<fn-def>
<br>
<br>
<a name="FN-DEF-KEY-EXCEPTION-RULE-INDEX"></a>function <tt><b>KEY-EXCEPTION-RULE-INDEX</b> : (rule &amp;optional mt)</tt><br>
Return a list of the keys to the next index level below RULE MT.<br>
Single value returned  satisfies LISTP.<fn-def> 
<br>
<br>
<a name="FN-DEF-KEY-FUNCTION-RULE-INDEX"></a>function <tt><b>KEY-FUNCTION-RULE-INDEX</b> : (func &amp;optional mt)</tt><br>
Return a list of the keys to the next index level below FUNC MT.<br>
Single value returned  satisfies LISTP.<fn-def> 
<br>
<br>
<a name="FN-DEF-KEY-GAF-ARG-INDEX"></a>function <tt><b>KEY-GAF-ARG-INDEX</b> : (term &amp;optional argnum pred)</tt><br>
Return a list of the keys to the next index level below TERM ARGNUM PRED.<br>
Single value returned  satisfies LISTP.<fn-def> 
<br>
<br>
<a name="FN-DEF-KEY-GENL-MT-RULE-INDEX"></a>function <tt><b>KEY-GENL-MT-RULE-INDEX</b> : (col &amp;optional sense mt)</tt><br>
Return a list of the keys to the next index level below COL SENSE MT.<br>
Single value returned  satisfies LISTP.<fn-def> 
<br>
<br>
<a name="FN-DEF-KEY-GENLS-RULE-INDEX"></a>function <tt><b>KEY-GENLS-RULE-INDEX</b> : (col &amp;optional sense mt)</tt><br>
Return a list of the keys to the next index level below COL SENSE MT.<br>
Single value returned  satisfies LISTP.<fn-def> 
<br>
<br>
<a name="FN-DEF-KEY-ISA-RULE-INDEX"></a>function <tt><b>KEY-ISA-RULE-INDEX</b> : (col &amp;optional sense mt)</tt><br>
Return a list of the keys to the next index level below COL SENSE MT.<br>
Single value returned  satisfies LISTP.<fn-def> 
<br>
<br>
<a name="FN-DEF-KEY-NART-ARG-INDEX"></a>function <tt><b>KEY-NART-ARG-INDEX</b> : (term &amp;optional argnum func)</tt><br>
Return a list of the keys to the next index level below TERM ARGNUM FUNC.<br>
Single value returned  satisfies LISTP.<fn-def> 
<br>
<br>
<a name="FN-DEF-KEY-PREDICATE-EXTENT-INDEX"></a>function <tt><b>KEY-PREDICATE-EXTENT-INDEX</b> : (pred)</tt><br>
Return a list of the keys to the next predicate-extent index level below PRED.<br>
Single value returned  satisfies LISTP.<fn-def> 
<br>
<br>
<a name="FN-DEF-KEY-PREDICATE-RULE-INDEX"></a>function <tt><b>KEY-PREDICATE-RULE-INDEX</b> : (pred &amp;optional sense mt)</tt><br>
Return a list of the keys to the next index level below PRED SENSE MT.<br>
Single value returned  satisfies LISTP.<fn-def>
<br>
<br>
<a name="FN-DEF-NUM-EXCEPTION-RULE-INDEX"></a>function <tt><b>NUM-EXCEPTION-RULE-INDEX</b> : (rule &amp;optional mt direction)</tt><br>
Return the raw assertion count at RULE MT DIRECTION.<br>
Single value returned  satisfies INTEGERP.<fn-def> 
<br>
<br>
<a name="FN-DEF-NUM-FUNCTION-EXTENT-INDEX"></a>function <tt><b>NUM-FUNCTION-EXTENT-INDEX</b> : (func)</tt><br>
Return the function extent of FUNC.<br>
Single value returned  satisfies INTEGERP.<fn-def> 
<br>
<br>
<a name="FN-DEF-NUM-FUNCTION-RULE-INDEX"></a>function <tt><b>NUM-FUNCTION-RULE-INDEX</b> : (func &amp;optional mt direction)</tt><br>
Return the raw assertion count at FUNC MT DIRECTION.<br>
Single value returned  satisfies INTEGERP.<fn-def> 
<br>
<br>
<a name="FN-DEF-NUM-GAF-ARG-INDEX"></a>function <tt><b>NUM-GAF-ARG-INDEX</b> : (term &amp;optional argnum pred mt)</tt><br>
Return the number of gafs indexed off of TERM ARGNUM PRED MT.<br>
Single value returned  satisfies INTEGERP.<fn-def> 
<br>
<br>
<a name="FN-DEF-NUM-GENL-MT-RULE-INDEX"></a>function <tt><b>NUM-GENL-MT-RULE-INDEX</b> : (col &amp;optional sense mt direction)</tt><br>
Return the raw assertion count at COL SENSE MT DIRECTION.<br>
Single value returned  satisfies INTEGERP.<fn-def> 
<br>
<br>
<a name="FN-DEF-NUM-GENLS-RULE-INDEX"></a>function <tt><b>NUM-GENLS-RULE-INDEX</b> : (col &amp;optional sense mt direction)</tt><br>
Return the raw assertion count at COL SENSE MT DIRECTION.<br>
Single value returned  satisfies INTEGERP.<fn-def> 
<br>
<br>
<a name="FN-DEF-NUM-INDEX"></a>function <tt><b>NUM-INDEX</b> : (term)</tt><br>
The total number of assertions indexed from TERM.<br>
Single value returned  satisfies INTEGERP.<fn-def> 
<br>
<br>
<a name="FN-DEF-NUM-ISA-RULE-INDEX"></a>function <tt><b>NUM-ISA-RULE-INDEX</b> : (col &amp;optional sense mt direction)</tt><br>
Return the raw assertion count at COL SENSE MT DIRECTION.<br>
Single value returned  satisfies INTEGERP.<fn-def> 
<br>
<br>
<a name="FN-DEF-NUM-MT-INDEX"></a>function <tt><b>NUM-MT-INDEX</b> : (term)</tt><br>
Return the number of assertions at the mt index for TERM.<br>
Single value returned  satisfies INTEGERP.<fn-def> 
<br>
<br>
<a name="FN-DEF-NUM-NART-ARG-INDEX"></a>function <tt><b>NUM-NART-ARG-INDEX</b> : (term &amp;optional argnum func)</tt><br>
Return the number of #$termOfUnit gafs indexed off of TERM ARGNUM FUNC.<br>
Single value returned  satisfies INTEGERP.<fn-def> 
<br>
<br>
<a name="FN-DEF-NUM-OTHER-INDEX"></a>function <tt><b>NUM-OTHER-INDEX</b> : (term)</tt><br>
Return the number of assertions at the other index for TERM.<br>
Single value returned  satisfies INTEGERP.<fn-def> 
<br>
<br>
<a name="FN-DEF-NUM-PREDICATE-EXTENT-INDEX"></a>function <tt><b>NUM-PREDICATE-EXTENT-INDEX</b> : (pred &amp;optional mt)</tt><br>
Return the assertion count at PRED MT.<br>
Single value returned  satisfies INTEGERP.<fn-def> 
<br>
<br>
<a name="FN-DEF-NUM-PREDICATE-RULE-INDEX"></a>function <tt><b>NUM-PREDICATE-RULE-INDEX</b> : (pred &amp;optional sense mt direction)</tt><br>
Return the raw assertion count at PRED SENSE MT DIRECTION.<br>
Single value returned  satisfies INTEGERP.<fn-def> 
<br>
<br>
<a name="FN-DEF-RELEVANT-NUM-FUNCTION-EXTENT-INDEX"></a>function <tt><b>RELEVANT-NUM-FUNCTION-EXTENT-INDEX</b> : (func)</tt><br>
Compute the function extent at relevant mts under FUNC.<br>
<code>   </code>This will be the entire function extent if #$BaseKB is relevant,<br>
<code>   </code>and zero otherwise.<br>
Single value returned  satisfies INTEGERP.<fn-def> 
<br>
<br>
<a name="FN-DEF-RELEVANT-NUM-GAF-ARG-INDEX"></a>function <tt><b>RELEVANT-NUM-GAF-ARG-INDEX</b> : (term &amp;optional argnum pred)</tt><br>
Return the assertion count at relevant mts under TERM ARGNUM PRED.<br>
Single value returned  satisfies INTEGERP.<fn-def> 
<br>
<br>
<a name="FN-DEF-RELEVANT-NUM-NART-ARG-INDEX"></a>function <tt><b>RELEVANT-NUM-NART-ARG-INDEX</b> : (term &amp;optional argnum func)</tt><br>
Compute the assertion count at relevant mts under TERM ARGNUM FUNC.<br>
<code>   </code>This will be the entire count extent if #$BaseKB is relevant,<br>
<code>   </code>and zero otherwise.<br>
Single value returned  satisfies INTEGERP.<fn-def> 
<br>
<br>
<a name="FN-DEF-RELEVANT-NUM-PREDICATE-EXTENT-INDEX"></a>function <tt><b>RELEVANT-NUM-PREDICATE-EXTENT-INDEX</b> : (pred)</tt><br>
Compute the assertion count at relevant mts under PRED.<br>
Single value returned  satisfies INTEGERP.<fn-def> 
<a name="Section-23"></a><h2>2.3 KB Mapping</h2>
<p>

Methods for mapping over the KB datastructures.  The WITH- macros also provide relevant mts for most functions in which
the microtheory is an optional argument.

<br>
<br>
<a name="FN-DEF-WITH-MT"></a>macro <tt><b>WITH-MT</b> : (mt &amp;body body)</tt><br>
MT and all its genl mts are relevant within BODY.<fn-def>
<br>
<br>
<a name="FN-DEF-WITH-ALL-MTS"></a>macro <tt><b>WITH-ALL-MTS</b> : (&amp;body body)</tt><br>
All mts are relevant within BODY.<fn-def>
<br>
<br>
<a name="FN-DEF-WITH-JUST-MT"></a>macro <tt><b>WITH-JUST-MT</b> : (mt &amp;body body)</tt><br>
Only MT is relevant within BODY (no genl mts).<fn-def>
<br>
<br>
<a name="FN-DEF-WITH-MT-LIST"></a>macro <tt><b>WITH-MT-LIST</b> : (mt-list &amp;body body)</tt><br>
Each mt in the list MT-LIST is relevant within BODY (no genl mts).<fn-def>
<br>
<br>
<a name="FN-DEF-WITH-ANY-MT"></a>macro <tt><b>WITH-ANY-MT</b> : (&amp;body body)</tt><br>
Any mt can be used for relevance for a particular inference within &amp;BODY.<fn-def> 
<br>
<br>
<a name="FN-DEF-WITH-GENL-MTS"></a>macro <tt><b>WITH-GENL-MTS</b> : (mt &amp;body body)</tt><br>
MT and all its genl mts are relevant within BODY.<fn-def> 
<br>
<br>
<a name="FN-DEF-MAP-MTS"></a>macro <tt><b>MAP-MTS</b> : ((var) &amp;body body)</tt><br>
Iterate over all microtheories, binding VAR to an mt and executing BODY.<fn-def>
<br>
<br>
<a name="FN-DEF-MAP-TERM"></a>function <tt><b>MAP-TERM</b> : (function term)</tt><br>
Apply FUNCTION to each assertion indexed from TERM.<br>
 FUNCTION must satisfy FUNCTION-SPEC-P.<br>
Single value returned  satisfies NULL.<fn-def>
<br>
<br>
<a name="FN-DEF-MAP-TERM-SELECTIVE"></a>function <tt><b>MAP-TERM-SELECTIVE</b> : (function term test &amp;optional truth)</tt><br>
Apply FUNCTION to each assertion indexed from TERM with TRUTH that passes TEST.<br>
<code>  </code>If TRUTH is nil, all assertions are mapped.<br>
 FUNCTION must satisfy FUNCTION-SPEC-P.<br>
 TEST must satisfy FUNCTION-SPEC-P.<br>
Single value returned  satisfies NULL.<fn-def>
<br>
<br>
<a name="FN-DEF-MAP-TERM-GAFS"></a>function <tt><b>MAP-TERM-GAFS</b> : (function term &amp;optional truth)</tt><br>
Apply FUNCTION to every gaf indexed from TERM.<br>
<code>   </code>If TRUTH is nil, all assertions are mapped.<br>
 FUNCTION must satisfy FUNCTION-SPEC-P.<br>
Single value returned  satisfies NULL.<fn-def>
<br>
<br>
<a name="FN-DEF-MAP-MT-CONTENTS"></a>function <tt><b>MAP-MT-CONTENTS</b> : (function term &amp;optional truth gafs-only)</tt><br>
Apply FUNCTION to each assertion with TRUTH in MT TERM.<br>
<code>   </code>If TRUTH is nil, all assertions are mapped.<br>
<code>   </code>If GAFS-ONLY, then only gafs are mapped.<br>
 FUNCTION must satisfy FUNCTION-SPEC-P.<br>
Single value returned  satisfies NULL.<fn-def>
<br>
<br>
<a name="FN-DEF-MAP-MT-INDEX"></a>function <tt><b>MAP-MT-INDEX</b> : (function mt &amp;optional truth gafs-only)</tt><br>
Apply FUNCTION to each assertion with TRUTH at mt index MT.<br>
<code>   </code>If TRUTH is nil, all assertions are mapped.<br>
<code>   </code>If GAFS-ONLY, then only gafs are mapped.<br>
 FUNCTION must satisfy FUNCTION-SPEC-P.<br>
Single value returned  satisfies NULL.<fn-def>
<br>
<br>
<a name="FN-DEF-MAP-OTHER-INDEX"></a>function <tt><b>MAP-OTHER-INDEX</b> : (function term &amp;optional truth gafs-only)</tt><br>
Apply FUNCTION to each assertion with TRUTH at other index TERM.<br>
<code>   </code>If TRUTH is nil, all assertions are mapped.<br>
<code>   </code>If GAFS-ONLY, then only gafs are mapped.<br>
 FUNCTION must satisfy FUNCTION-SPEC-P.<br>
Single value returned  satisfies NULL.<fn-def>
<br>
<br>
<a name="FN-DEF-GATHER-INDEX"></a>function <tt><b>GATHER-INDEX</b> : (term &amp;optional remove-duplicates?)</tt><br>
Return a list of all mt-relevant assertions indexed via TERM.<br>
If REMOVE-DUPLICATES? is non-nil, assertions are guaranteed to only be listed once.<br>
Single value returned is a list of elements satisfying ASSERTION-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-GATHER-INDEX-IN-ANY-MT"></a>function <tt><b>GATHER-INDEX-IN-ANY-MT</b> : (term &amp;optional remove-duplicates?)</tt><br>
Return a list of all assertions indexed via TERM.<br>
If REMOVE-DUPLICATES? is non-nil, assertions are guaranteed to only be listed once.<br>
Single value returned is a list of elements satisfying ASSERTION-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-GATHER-EXCEPTION-RULE-INDEX"></a>function <tt><b>GATHER-EXCEPTION-RULE-INDEX</b> : (rule &amp;optional mt direction)</tt><br>
Return a list of all non-gaf assertions (rules) such that:<br>
a) it has a positive literal of the form (abnormal &lt;whatever&gt; RULE)<br>
b) if MT is non-nil, then MT must be its microtheory<br>
c) if DIRECTION is non-nil, then DIRECTION must be its direction.<br>
Single value returned is a list of elements satisfying ASSERTION-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-GATHER-FUNCTION-EXTENT-INDEX"></a>function <tt><b>GATHER-FUNCTION-EXTENT-INDEX</b> : (func)</tt><br>
Return a list of all #$termOfUnit assertions such that:<br>
FUNC is the functor of the naut arg2.<br>
Single value returned is a list of elements satisfying ASSERTION-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-GATHER-FUNCTION-RULE-INDEX"></a>function <tt><b>GATHER-FUNCTION-RULE-INDEX</b> : (func &amp;optional mt direction)</tt><br>
Return a list of all non-gaf assertions (rules) such that:<br>
a) it has a negative literal of the form (termOfUnit &lt;whatever&gt; (FUNC . &lt;whatever&gt;))<br>
b) if MT is non-nil, then MT must be its microtheory<br>
c) if DIRECTION is non-nil, then DIRECTION must be its direction.<br>
Single value returned is a list of elements satisfying ASSERTION-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-GATHER-GAF-ARG-INDEX"></a>function <tt><b>GATHER-GAF-ARG-INDEX</b> : (term argnum &amp;optional pred mt truth)</tt><br>
Return a list of all gaf assertions such that:<br>
a) TERM is its ARGNUMth argument<br>
b) if TRUTH is non-nil, then TRUTH is its truth value<br>
c) if PRED is non-nil, then PRED must be its predicate<br>
d) if MT is non-nil, then MT must be its microtheory (and PRED must be non-nil).<br>
 ARGNUM must satisfy POSITIVE-INTEGER-P.<br>
Single value returned is a list of elements satisfying ASSERTION-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-GATHER-GENL-MT-RULE-INDEX"></a>function <tt><b>GATHER-GENL-MT-RULE-INDEX</b> : (genl-mt sense &amp;optional rule-mt direction)</tt><br>
Return a list of all non-gaf assertions (rules) such that:<br>
a) if SENSE is :pos, it has a positive literal of the form (genlMt &lt;whatever&gt; GENL-MT)<br>
b) if SENSE is :neg, it has a negative literal of the form (genlMt &lt;whatever&gt; GENL-MT)<br>
c) if RULE-MT is non-nil, then RULE-MT must be its microtheory<br>
d) if DIRECTION is non-nil, then DIRECTION must be its direction.<br>
 SENSE must satisfy SENSE-P.<br>
Single value returned is a list of elements satisfying ASSERTION-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-GATHER-GENLS-RULE-INDEX"></a>function <tt><b>GATHER-GENLS-RULE-INDEX</b> : (collection sense &amp;optional mt direction)</tt><br>
Return a list of all non-gaf assertions (rules) such that:<br>
a) if SENSE is :pos, it has a positive literal of the form (genls &lt;whatever&gt; COLLECTION)<br>
b) if SENSE is :neg, it has a negative literal of the form (genls &lt;whatever&gt; COLLECTION)<br>
c) if MT is non-nil, then MT must be its microtheory<br>
d) if DIRECTION is non-nil, then DIRECTION must be its direction.<br>
 SENSE must satisfy SENSE-P.<br>
Single value returned is a list of elements satisfying ASSERTION-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-GATHER-ISA-RULE-INDEX"></a>function <tt><b>GATHER-ISA-RULE-INDEX</b> : (collection sense &amp;optional mt direction)</tt><br>
Return a list of all non-gaf assertions (rules) such that:<br>
a) if SENSE is :pos, it has a positive literal of the form (isa &lt;whatever&gt; COLLECTION)<br>
b) if SENSE is :neg, it has a negative literal of the form (isa &lt;whatever&gt; COLLECTION)<br>
c) if MT is non-nil, then MT must be its microtheory<br>
d) if DIRECTION is non-nil, then DIRECTION must be its direction.<br>
 SENSE must satisfy SENSE-P.<br>
Single value returned is a list of elements satisfying ASSERTION-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-GATHER-MT-INDEX"></a>function <tt><b>GATHER-MT-INDEX</b> : (term)</tt><br>
Return a list of all assertions such that TERM is its microtheory.<br>
Single value returned is a list of elements satisfying ASSERTION-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-GATHER-NART-ARG-INDEX"></a>function <tt><b>GATHER-NART-ARG-INDEX</b> : (term argnum &amp;optional func)</tt><br>
Return a list of all #$termOfUnit assertions with a naut arg2 such that:<br>
a) TERM is its ARGNUMth argument<br>
b) if FUNC is non-nil, then FUNC must be its functor<br>
 ARGNUM must satisfy POSITIVE-INTEGER-P.<br>
Single value returned is a list of elements satisfying ASSERTION-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-GATHER-OTHER-INDEX"></a>function <tt><b>GATHER-OTHER-INDEX</b> : (term)</tt><br>
Return a list of other assertions mentioning TERM but not indexed in any other more useful manner.<br>
Single value returned is a list of elements satisfying ASSERTION-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-GATHER-PREDICATE-EXTENT-INDEX"></a>function <tt><b>GATHER-PREDICATE-EXTENT-INDEX</b> : (pred &amp;optional mt truth)</tt><br>
Return a list of all gaf assertions such that:<br>
a) PRED is its predicate<br>
b) if TRUTH is non-nil, then TRUTH is its truth value<br>
c) if MT is non-nil, then MT must be its microtheory.<br>
Single value returned is a list of elements satisfying ASSERTION-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-GATHER-PREDICATE-RULE-INDEX"></a>function <tt><b>GATHER-PREDICATE-RULE-INDEX</b> : (pred sense &amp;optional mt direction)</tt><br>
Return a list of all non-gaf assertions (rules) such that:<br>
a) if SENSE is :pos, it has PRED as a predicate in a positive literal<br>
b) if SENSE is :neg, it has PRED as a predicate in a negative literal<br>
c) if MT is non-nil, then MT must be its microtheory<br>
d) if DIRECTION is non-nil, then DIRECTION must be its direction.<br>
 SENSE must satisfy SENSE-P.<br>
Single value returned is a list of elements satisfying ASSERTION-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-GATHER-TERM-ASSERTIONS"></a>function <tt><b>GATHER-TERM-ASSERTIONS</b> : (term &amp;optional mt)</tt><br>
Return a list of all mt-relevant assertions of TERM.<br>
Single value returned is a list of elements satisfying ASSERTION-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-FPRED-VALUE"></a>function <tt><b>FPRED-VALUE</b> : (term pred &amp;optional index-arg gather-arg truth)</tt><br>
Find the first gaf assertion such that:<br>
<code> </code>(a) the assertion is in a relevant microtheory (relevance is established outside)<br>
<code> </code>(b) if TRUTH is non-nil, the assertion has TRUTH as its truth value<br>
<code> </code>(c) PRED is the predicate used.<br>
<code> </code>(d) TERM is the term in the INDEX-ARG position.<br>
<code> </code>Return the term in the GATHER-ARG position if such an assertion exists.<br>
<code> </code>Otherwise, return NIL.<br>
 TERM must satisfy INDEXED-TERM-P.<br>
 PRED must satisfy FORT-P.<br>
 INDEX-ARG must satisfy INTEGERP.<br>
 GATHER-ARG must satisfy INTEGERP.<br>
 TRUTH must satisfy TRUTH-P.<br>
Single value returned satisfies HL-TERM-P or is NIL.<fn-def>
<br>
<br>
<a name="FN-DEF-FPRED-VALUE-IN-MT"></a>function <tt><b>FPRED-VALUE-IN-MT</b> : (term pred mt &amp;optional index-arg gather-arg truth)</tt><br>
Find the first gaf assertion such that:<br>
<code> </code>(a) the assertion is in microtheory MT<br>
<code> </code>(b) if TRUTH is non-nil, the assertion has TRUTH as its truth value<br>
<code> </code>(c) PRED is the predicate used.<br>
<code> </code>(d) TERM is the term in the INDEX-ARG position.<br>
<code> </code>Return the term in the GATHER-ARG position if such an assertion exists.<br>
<code> </code>Otherwise, return NIL.<br>
 TERM must satisfy INDEXED-TERM-P.<br>
 PRED must satisfy FORT-P.<br>
 MT must satisfy HLMT-P.<br>
 INDEX-ARG must satisfy INTEGERP.<br>
 GATHER-ARG must satisfy INTEGERP.<br>
 TRUTH must satisfy TRUTH-P.<br>
Single value returned satisfies HL-TERM-P or is NIL.<fn-def>
<br>
<br>
<a name="FN-DEF-FPRED-VALUE-IN-MTS"></a>function <tt><b>FPRED-VALUE-IN-MTS</b> : (term pred mts &amp;optional index-arg gather-arg truth)</tt><br>
Find the first gaf assertion such that:<br>
<code> </code>(a) the assertion is in one of the microtheories in the list MTS<br>
<code> </code>(b) if TRUTH is non-nil, the assertion has TRUTH as its truth value<br>
<code> </code>(c) PRED is the predicate used.<br>
<code> </code>(d) TERM is the term in the INDEX-ARG position.<br>
<code> </code>Return the term in the GATHER-ARG position if such an assertion exists.<br>
<code> </code>Otherwise, return NIL.<br>
 TERM must satisfy INDEXED-TERM-P.<br>
 PRED must satisfy FORT-P.<br>
 MTS must satisfy LISTP.<br>
 INDEX-ARG must satisfy INTEGERP.<br>
 GATHER-ARG must satisfy INTEGERP.<br>
 TRUTH must satisfy TRUTH-P.<br>
Single value returned satisfies HL-TERM-P or is NIL.<fn-def>
<br>
<br>
<a name="FN-DEF-FPRED-VALUE-IN-ANY-MT"></a>function <tt><b>FPRED-VALUE-IN-ANY-MT</b> : (term pred &amp;optional index-arg gather-arg truth)</tt><br>
Find the first gaf assertion such that:<br>
<code> </code>(a) the assertion is allowed to be in any microtheory<br>
<code> </code>(b) if TRUTH is non-nil, the assertion has TRUTH as its truth value<br>
<code> </code>(c) PRED is the predicate used.<br>
<code> </code>(d) TERM is the term in the INDEX-ARG position.<br>
<code> </code>Return the term in the GATHER-ARG position if such an assertion exists.<br>
<code> </code>Otherwise, return NIL.<br>
 TERM must satisfy INDEXED-TERM-P.<br>
 PRED must satisfy FORT-P.<br>
 INDEX-ARG must satisfy INTEGERP.<br>
 GATHER-ARG must satisfy INTEGERP.<br>
 TRUTH must satisfy TRUTH-P.<br>
Single value returned satisfies HL-TERM-P or is NIL.<fn-def>
<br>
<br>
<a name="FN-DEF-FPRED-VALUE-IN-RELEVANT-MTS"></a>function <tt><b>FPRED-VALUE-IN-RELEVANT-MTS</b> : (term pred &amp;optional mt index-arg gather-arg truth)</tt><br>
If MT is NIL, behaves like FPRED-VALUE.  Otherwise, behaves like FPRED-VALUE-IN-MT.<br>
 TERM must satisfy INDEXED-TERM-P.<br>
 PRED must satisfy FORT-P.<br>
 INDEX-ARG must satisfy INTEGERP.<br>
 GATHER-ARG must satisfy INTEGERP.<br>
 TRUTH must satisfy TRUTH-P.<br>
Single value returned satisfies HL-TERM-P or is NIL.<fn-def>
<br>
<br>
<a name="FN-DEF-PRED-VALUES"></a>function <tt><b>PRED-VALUES</b> : (term pred &amp;optional index-arg gather-arg truth)</tt><br>
Find all gaf assertions such that:<br>
<code> </code>(a) the assertion is in a relevant microtheory (relevance is established outside)<br>
<code> </code>(b) if TRUTH is non-nil, the assertion has TRUTH as its truth value<br>
<code> </code>(c) PRED is the predicate used.<br>
<code> </code>(d) TERM is the term in the INDEX-ARG position.<br>
<code> </code>Return a list of the terms in the GATHER-ARG position of all such assertions.<br>
 TERM must satisfy INDEXED-TERM-P.<br>
 PRED must satisfy FORT-P.<br>
 INDEX-ARG must satisfy INTEGERP.<br>
 GATHER-ARG must satisfy INTEGERP.<br>
 TRUTH must satisfy TRUTH-P.<br>
Single value returned is a list of elements satisfying HL-TERM-P.<fn-def>
<br>
<br>
<a name="FN-DEF-PRED-VALUES-IN-MT"></a>function <tt><b>PRED-VALUES-IN-MT</b> : (term pred mt &amp;optional index-arg gather-arg truth)</tt><br>
Find all gaf assertions such that:<br>
<code> </code>(a) the assertion is in microtheory MT<br>
<code> </code>(b) if TRUTH is non-nil, the assertion has TRUTH as its truth value<br>
<code> </code>(c) PRED is the predicate used.<br>
<code> </code>(d) TERM is the term in the INDEX-ARG position.<br>
<code> </code>Return a list of the terms in the GATHER-ARG position of all such assertions.<br>
 TERM must satisfy INDEXED-TERM-P.<br>
 PRED must satisfy FORT-P.<br>
 MT must satisfy HLMT-P.<br>
 INDEX-ARG must satisfy INTEGERP.<br>
 GATHER-ARG must satisfy INTEGERP.<br>
 TRUTH must satisfy TRUTH-P.<br>
Single value returned is a list of elements satisfying HL-TERM-P.<fn-def>
<br>
<br>
<a name="FN-DEF-PRED-VALUES-IN-MTS"></a>function <tt><b>PRED-VALUES-IN-MTS</b> : (term pred mts &amp;optional index-arg gather-arg truth)</tt><br>
Find all gaf assertions such that:<br>
<code> </code>(a) the assertion is in one of the microtheories in the list MTS<br>
<code> </code>(b) if TRUTH is non-nil, the assertion has TRUTH as its truth value<br>
<code> </code>(c) PRED is the predicate used.<br>
<code> </code>(d) TERM is the term in the INDEX-ARG position.<br>
<code> </code>Return a list of the terms in the GATHER-ARG position of all such assertions.<br>
 TERM must satisfy INDEXED-TERM-P.<br>
 PRED must satisfy FORT-P.<br>
 MTS must satisfy LISTP.<br>
 INDEX-ARG must satisfy INTEGERP.<br>
 GATHER-ARG must satisfy INTEGERP.<br>
 TRUTH must satisfy TRUTH-P.<br>
Single value returned is a list of elements satisfying HL-TERM-P.<fn-def>
<br>
<br>
<a name="FN-DEF-PRED-VALUES-IN-ANY-MT"></a>function <tt><b>PRED-VALUES-IN-ANY-MT</b> : (term pred &amp;optional index-arg gather-arg truth)</tt><br>
Find all gaf assertions such that:<br>
<code> </code>(a) the assertion is allowed to be in any microtheory<br>
<code> </code>(b) if TRUTH is non-nil, the assertion has TRUTH as its truth value<br>
<code> </code>(c) PRED is the predicate used.<br>
<code> </code>(d) TERM is the term in the INDEX-ARG position.<br>
<code> </code>Return a list of the terms in the GATHER-ARG position of all such assertions.<br>
 TERM must satisfy INDEXED-TERM-P.<br>
 PRED must satisfy FORT-P.<br>
 INDEX-ARG must satisfy INTEGERP.<br>
 GATHER-ARG must satisfy INTEGERP.<br>
 TRUTH must satisfy TRUTH-P.<br>
Single value returned is a list of elements satisfying HL-TERM-P.<fn-def>
<br>
<br>
<a name="FN-DEF-PRED-VALUES-IN-RELEVANT-MTS"></a>function <tt><b>PRED-VALUES-IN-RELEVANT-MTS</b> : (term pred &amp;optional mt index-arg gather-arg truth)</tt><br>
If MT is NIL, behaves like PRED-VALUES.  Otherwise, behaves like PRED-VALUES-IN-MT<br>
 TERM must satisfy INDEXED-TERM-P.<br>
 PRED must satisfy FORT-P.<br>
 INDEX-ARG must satisfy INTEGERP.<br>
 GATHER-ARG must satisfy INTEGERP.<br>
 TRUTH must satisfy TRUTH-P.<br>
Single value returned is a list of elements satisfying HL-TERM-P.<fn-def>
<br>
<br>
<a name="FN-DEF-PRED-REFS"></a>function <tt><b>PRED-REFS</b> : (pred &amp;optional gather-arg truth)</tt><br>
Find all gaf assertions such that:<br>
<code> </code>(a) the assertion is in a relevant microtheory (relevance is established outside)<br>
<code> </code>(b) if TRUTH is non-nil, the assertion has TRUTH as its truth value<br>
<code> </code>(c) PRED is the predicate used.<br>
<code> </code>Return a list of the terms in the GATHER-ARG position of all such assertions.<br>
 PRED must satisfy FORT-P.<br>
 GATHER-ARG must satisfy INTEGERP.<br>
 TRUTH must satisfy TRUTH-P.<br>
Single value returned is a list of elements satisfying HL-TERM-P.<fn-def>
<br>
<br>
<a name="FN-DEF-PRED-REFS-IN-MT"></a>function <tt><b>PRED-REFS-IN-MT</b> : (pred mt &amp;optional gather-arg truth)</tt><br>
Find all gaf assertions such that:<br>
<code> </code>(a) the assertion is in microtheory MT<br>
<code> </code>(b) if TRUTH is non-nil, the assertion has TRUTH as its truth value<br>
<code> </code>(c) PRED is the predicate used.<br>
<code> </code>Return a list of the terms in the GATHER-ARG position of all such assertions.<br>
 PRED must satisfy FORT-P.<br>
 MT must satisfy HLMT-P.<br>
 GATHER-ARG must satisfy INTEGERP.<br>
 TRUTH must satisfy TRUTH-P.<br>
Single value returned is a list of elements satisfying HL-TERM-P.<fn-def>
<br>
<br>
<a name="FN-DEF-PRED-REFS-IN-MTS"></a>function <tt><b>PRED-REFS-IN-MTS</b> : (pred mts &amp;optional gather-arg truth)</tt><br>
Find all gaf assertions such that:<br>
<code> </code>(a) the assertion is in one of the microtheories in the list MTS<br>
<code> </code>(b) if TRUTH is non-nil, the assertion has TRUTH as its truth value<br>
<code> </code>(c) PRED is the predicate used.<br>
<code> </code>Return a list of the terms in the GATHER-ARG position of all such assertions.<br>
 PRED must satisfy FORT-P.<br>
 MTS must satisfy LISTP.<br>
 GATHER-ARG must satisfy INTEGERP.<br>
 TRUTH must satisfy TRUTH-P.<br>
Single value returned is a list of elements satisfying HL-TERM-P.<fn-def>
<br>
<br>
<a name="FN-DEF-PRED-REFS-IN-ANY-MT"></a>function <tt><b>PRED-REFS-IN-ANY-MT</b> : (pred &amp;optional gather-arg truth)</tt><br>
Find all gaf assertions such that:<br>
<code> </code>(a) the assertion is allowed to be in any microtheory<br>
<code> </code>(b) if TRUTH is non-nil, the assertion has TRUTH as its truth value<br>
<code> </code>(c) PRED is the predicate used.<br>
<code> </code>Return a list of the terms in the GATHER-ARG position of all such assertions.<br>
 PRED must satisfy FORT-P.<br>
 GATHER-ARG must satisfy INTEGERP.<br>
 TRUTH must satisfy TRUTH-P.<br>
Single value returned is a list of elements satisfying HL-TERM-P.<fn-def>
<br>
<br>
<a name="FN-DEF-PRED-REFS-IN-RELEVANT-MTS"></a>function <tt><b>PRED-REFS-IN-RELEVANT-MTS</b> : (pred &amp;optional mt gather-arg truth)</tt><br>
If MT is NIL, behaves like PRED-REFS.  Otherwise, behaves like PRED-REFS-IN-MT<br>
 PRED must satisfy FORT-P.<br>
 GATHER-ARG must satisfy INTEGERP.<br>
 TRUTH must satisfy TRUTH-P.<br>
Single value returned is a list of elements satisfying HL-TERM-P.<fn-def>
<br>
<br>
<a name="FN-DEF-SOME-PRED-VALUE"></a>function <tt><b>SOME-PRED-VALUE</b> : (term pred &amp;optional index-arg truth)</tt><br>
Find the first gaf assertion such that:<br>
<code> </code>(a) the assertion is in a relevant microtheory (relevance is established outside)<br>
<code> </code>(b) if TRUTH is non-nil, the assertion has TRUTH as its truth value<br>
<code> </code>(c) PRED is the predicate used.<br>
<code> </code>(d) TERM is the term in the INDEX-ARG position.<br>
<code> </code>Return T if such an assertion exists, otherwise return NIL.<br>
 TERM must satisfy INDEXED-TERM-P.<br>
 PRED must satisfy FORT-P.<br>
 INDEX-ARG must satisfy INTEGERP.<br>
 TRUTH must satisfy TRUTH-P.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-SOME-PRED-VALUE-IN-MT"></a>function <tt><b>SOME-PRED-VALUE-IN-MT</b> : (term pred mt &amp;optional index-arg truth)</tt><br>
Find the first gaf assertion such that:<br>
<code> </code>(a) the assertion is in microtheory MT<br>
<code> </code>(b) if TRUTH is non-nil, the assertion has TRUTH as its truth value<br>
<code> </code>(c) PRED is the predicate used.<br>
<code> </code>(d) TERM is the term in the INDEX-ARG position.<br>
<code> </code>Return T if such an assertion exists, otherwise return NIL.<br>
 TERM must satisfy INDEXED-TERM-P.<br>
 PRED must satisfy FORT-P.<br>
 MT must satisfy HLMT-P.<br>
 INDEX-ARG must satisfy INTEGERP.<br>
 TRUTH must satisfy TRUTH-P.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-SOME-PRED-VALUE-IN-MTS"></a>function <tt><b>SOME-PRED-VALUE-IN-MTS</b> : (term pred mts &amp;optional index-arg truth)</tt><br>
Find the first gaf assertion such that:<br>
<code> </code>(a) the assertion is in one of the microtheories in the list MTS<br>
<code> </code>(b) if TRUTH is non-nil, the assertion has TRUTH as its truth value<br>
<code> </code>(c) PRED is the predicate used.<br>
<code> </code>(d) TERM is the term in the INDEX-ARG position.<br>
<code> </code>Return T if such an assertion exists, otherwise return NIL.<br>
 TERM must satisfy INDEXED-TERM-P.<br>
 PRED must satisfy FORT-P.<br>
 MTS must satisfy LISTP.<br>
 INDEX-ARG must satisfy INTEGERP.<br>
 TRUTH must satisfy TRUTH-P.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-SOME-PRED-VALUE-IN-ANY-MT"></a>function <tt><b>SOME-PRED-VALUE-IN-ANY-MT</b> : (term pred &amp;optional index-arg truth)</tt><br>
Find the first gaf assertion such that:<br>
<code> </code>(a) the assertion is allowed to be in any microtheory<br>
<code> </code>(b) if TRUTH is non-nil, the assertion has TRUTH as its truth value<br>
<code> </code>(c) PRED is the predicate used.<br>
<code> </code>(d) TERM is the term in the INDEX-ARG position.<br>
<code> </code>Return T if such an assertion exists, otherwise return NIL.<br>
 TERM must satisfy INDEXED-TERM-P.<br>
 PRED must satisfy FORT-P.<br>
 INDEX-ARG must satisfy INTEGERP.<br>
 TRUTH must satisfy TRUTH-P.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-SOME-PRED-VALUE-IN-RELEVANT-MTS"></a>function <tt><b>SOME-PRED-VALUE-IN-RELEVANT-MTS</b> : (term pred &amp;optional mt index-arg truth)</tt><br>
If MT is NIL, behaves like SOME-PRED-VALUE.  Otherwise, behaves like SOME-PRED-VALUE-IN-MT<br>
 TERM must satisfy INDEXED-TERM-P.<br>
 PRED must satisfy FORT-P.<br>
 INDEX-ARG must satisfy INTEGERP.<br>
 TRUTH must satisfy TRUTH-P.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-PRED-U-V-HOLDS"></a>function <tt><b>PRED-U-V-HOLDS</b> : (pred u v &amp;optional u-arg v-arg truth)</tt><br>
Find the first gaf assertion such that:<br>
<code> </code>(a) the assertion is in a relevant microtheory (relevance is established outside)<br>
<code> </code>(b) if TRUTH is non-nil, the assertion has TRUTH as its truth value<br>
<code> </code>(c) PRED is the predicate used.<br>
<code> </code>(d) U is the term in the U-ARG position.<br>
<code> </code>(e) V is the term in the V-ARG position.<br>
<code> </code>Return T if such an assertion exists, otherwise return NIL.<br>
 PRED must satisfy FORT-P.<br>
 U must satisfy INDEXED-TERM-P.<br>
 V must satisfy HL-TERM-P.<br>
 U-ARG must satisfy INTEGERP.<br>
 V-ARG must satisfy INTEGERP.<br>
 TRUTH must satisfy TRUTH-P.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-PRED-U-V-HOLDS-IN-MT"></a>function <tt><b>PRED-U-V-HOLDS-IN-MT</b> : (pred u v mt &amp;optional u-arg v-arg truth)</tt><br>
Find the first gaf assertion such that:<br>
<code> </code>(a) the assertion is in microtheory MT<br>
<code> </code>(b) if TRUTH is non-nil, the assertion has TRUTH as its truth value<br>
<code> </code>(c) PRED is the predicate used.<br>
<code> </code>(d) U is the term in the U-ARG position.<br>
<code> </code>(e) V is the term in the V-ARG position.<br>
<code> </code>Return T if such an assertion exists, otherwise return NIL.<br>
 PRED must satisfy FORT-P.<br>
 U must satisfy INDEXED-TERM-P.<br>
 V must satisfy HL-TERM-P.<br>
 MT must satisfy HLMT-P.<br>
 U-ARG must satisfy INTEGERP.<br>
 V-ARG must satisfy INTEGERP.<br>
 TRUTH must satisfy TRUTH-P.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-PRED-U-V-HOLDS-IN-MTS"></a>function <tt><b>PRED-U-V-HOLDS-IN-MTS</b> : (pred u v mts &amp;optional u-arg v-arg truth)</tt><br>
Find the first gaf assertion such that:<br>
<code> </code>(a) the assertion is in one of the microtheories in the list MTS<br>
<code> </code>(b) if TRUTH is non-nil, the assertion has TRUTH as its truth value<br>
<code> </code>(c) PRED is the predicate used.<br>
<code> </code>(d) U is the term in the U-ARG position.<br>
<code> </code>(e) V is the term in the V-ARG position.<br>
<code> </code>Return T if such an assertion exists, otherwise return NIL.<br>
 PRED must satisfy FORT-P.<br>
 U must satisfy INDEXED-TERM-P.<br>
 V must satisfy HL-TERM-P.<br>
 MTS must satisfy LISTP.<br>
 U-ARG must satisfy INTEGERP.<br>
 V-ARG must satisfy INTEGERP.<br>
 TRUTH must satisfy TRUTH-P.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-PRED-U-V-HOLDS-IN-ANY-MT"></a>function <tt><b>PRED-U-V-HOLDS-IN-ANY-MT</b> : (pred u v &amp;optional u-arg v-arg truth)</tt><br>
Find the first gaf assertion such that:<br>
<code> </code>(a) the assertion is allowed to be in any microtheory<br>
<code> </code>(b) if TRUTH is non-nil, the assertion has TRUTH as its truth value<br>
<code> </code>(c) PRED is the predicate used.<br>
<code> </code>(d) U is the term in the U-ARG position.<br>
<code> </code>(e) V is the term in the V-ARG position.<br>
<code> </code>Return T if such an assertion exists, otherwise return NIL.<br>
 PRED must satisfy FORT-P.<br>
 U must satisfy INDEXED-TERM-P.<br>
 V must satisfy HL-TERM-P.<br>
 U-ARG must satisfy INTEGERP.<br>
 V-ARG must satisfy INTEGERP.<br>
 TRUTH must satisfy TRUTH-P.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-PRED-U-V-HOLDS-IN-RELEVANT-MTS"></a>function <tt><b>PRED-U-V-HOLDS-IN-RELEVANT-MTS</b> : (pred u v &amp;optional mt u-arg v-arg truth)</tt><br>
If MT is NIL, behaves like PRED-U-V-HOLDS.  Otherwise, behaves like PRED-U-V-HOLDS-IN-MT<br>
 PRED must satisfy FORT-P.<br>
 U must satisfy INDEXED-TERM-P.<br>
 V must satisfy HL-TERM-P.<br>
 U-ARG must satisfy INTEGERP.<br>
 V-ARG must satisfy INTEGERP.<br>
 TRUTH must satisfy TRUTH-P.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-PRED-VALUE-TUPLES"></a>function <tt><b>PRED-VALUE-TUPLES</b> : (term pred index-arg gather-args &amp;optional truth)</tt><br>
Find all gaf assertions such that:<br>
<code> </code>(a) the assertion is in a relevant microtheory (relevance is established outside)<br>
<code> </code>(b) if TRUTH is non-nil, the assertion has TRUTH as its truth value<br>
<code> </code>(c) PRED is the predicate used.<br>
<code> </code>(d) TERM is the term in the INDEX-ARG position.<br>
<code> </code>Return a list of tuples formed from the GATHER-ARGS positions of all such assertions.<br>
 TERM must satisfy INDEXED-TERM-P.<br>
 PRED must satisfy FORT-P.<br>
 INDEX-ARG must satisfy INTEGERP.<br>
 GATHER-ARGS must satisfy LISTP.<br>
 TRUTH must satisfy TRUTH-P.<br>
Single value returned is a list of elements satisfying LISTP.<fn-def>
<br>
<br>
<a name="FN-DEF-PRED-VALUE-TUPLES-IN-MT"></a>function <tt><b>PRED-VALUE-TUPLES-IN-MT</b> : (term pred index-arg gather-args mt &amp;optional truth)</tt><br>
Find all gaf assertions such that:<br>
<code> </code>(a) the assertion is microtheory MT<br>
<code> </code>(b) if TRUTH is non-nil, the assertion has TRUTH as its truth value<br>
<code> </code>(c) PRED is the predicate used.<br>
<code> </code>(d) TERM is the term in the INDEX-ARG position.<br>
<code> </code>Return a list of tuples formed from the GATHER-ARGS positions of all such assertions.<br>
 TERM must satisfy INDEXED-TERM-P.<br>
 PRED must satisfy FORT-P.<br>
 INDEX-ARG must satisfy INTEGERP.<br>
 GATHER-ARGS must satisfy LISTP.<br>
 MT must satisfy HLMT-P.<br>
 TRUTH must satisfy TRUTH-P.<br>
Single value returned is a list of elements satisfying LISTP.<fn-def>
<br>
<br>
<a name="FN-DEF-PRED-VALUE-TUPLES-IN-MTS"></a>function <tt><b>PRED-VALUE-TUPLES-IN-MTS</b> : (term pred index-arg gather-args mts &amp;optional truth)</tt><br>
Find all gaf assertions such that:<br>
<code> </code>(a) the assertion is in one of the microtheories in the list MTS<br>
<code> </code>(b) if TRUTH is non-nil, the assertion has TRUTH as its truth value<br>
<code> </code>(c) PRED is the predicate used.<br>
<code> </code>(d) TERM is the term in the INDEX-ARG position.<br>
<code> </code>Return a list of tuples formed from the GATHER-ARGS positions of all such assertions.<br>
 TERM must satisfy INDEXED-TERM-P.<br>
 PRED must satisfy FORT-P.<br>
 INDEX-ARG must satisfy INTEGERP.<br>
 GATHER-ARGS must satisfy LISTP.<br>
 MTS must satisfy LISTP.<br>
 TRUTH must satisfy TRUTH-P.<br>
Single value returned is a list of elements satisfying LISTP.<fn-def>
<br>
<br>
<a name="FN-DEF-PRED-VALUE-TUPLES-IN-ANY-MT"></a>function <tt><b>PRED-VALUE-TUPLES-IN-ANY-MT</b> : (term pred index-arg gather-args &amp;optional truth)</tt><br>
Find all gaf assertions such that:<br>
<code> </code>(a) the assertion is allowed to be from any microtheory<br>
<code> </code>(b) if TRUTH is non-nil, the assertion has TRUTH as its truth value<br>
<code> </code>(c) PRED is the predicate used.<br>
<code> </code>(d) TERM is the term in the INDEX-ARG position.<br>
<code> </code>Return a list of tuples formed from the GATHER-ARGS positions of all such assertions.<br>
 TERM must satisfy INDEXED-TERM-P.<br>
 PRED must satisfy FORT-P.<br>
 INDEX-ARG must satisfy INTEGERP.<br>
 GATHER-ARGS must satisfy LISTP.<br>
 TRUTH must satisfy TRUTH-P.<br>
Single value returned is a list of elements satisfying LISTP.<fn-def>
<br>
<br>
<a name="FN-DEF-PRED-VALUE-TUPLES-IN-RELEVANT-MTS"></a>function <tt><b>PRED-VALUE-TUPLES-IN-RELEVANT-MTS</b> : (term pred index-arg gather-args &amp;optional mt truth)</tt><br>
If MT is NIL, behaves like PRED-VALUE-TUPLES.  Otherwise, behaves like PRED-VALUE-TUPLES-IN-MT<br>
 TERM must satisfy INDEXED-TERM-P.<br>
 PRED must satisfy FORT-P.<br>
 INDEX-ARG must satisfy INTEGERP.<br>
 GATHER-ARGS must satisfy LISTP.<br>
 TRUTH must satisfy TRUTH-P.<br>
Single value returned is a list of elements satisfying LISTP.<fn-def>

<a name="Section-24"></a><h2>2.4 KB Accessors</h2>
<p>

Miscellaneous methods useful for interacting with the KB

<br>
<br>
<a name="FN-DEF-REFLEXIVE-PREDICATE?"></a>function <tt><b>REFLEXIVE-PREDICATE?</b> : (predicate &amp;optional mt)</tt><br>
Return T iff PREDICATE is a reflexive predicate.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-IRREFLEXIVE-PREDICATE?"></a>function <tt><b>IRREFLEXIVE-PREDICATE?</b> : (predicate &amp;optional mt)</tt><br>
Return T iff PREDICATE is an irreflexive predicate.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-SYMMETRIC-PREDICATE?"></a>function <tt><b>SYMMETRIC-PREDICATE?</b> : (predicate &amp;optional mt)</tt><br>
Return T iff PREDICATE is a symmetric predicate.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-ASYMMETRIC-PREDICATE?"></a>function <tt><b>ASYMMETRIC-PREDICATE?</b> : (predicate &amp;optional mt)</tt><br>
Return T iff PREDICATE is an asymmetric predicate.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-ANTI-SYMMETRIC-PREDICATE?"></a>function <tt><b>ANTI-SYMMETRIC-PREDICATE?</b> : (predicate &amp;optional mt)</tt><br>
Return T iff PREDICATE is an anti-symmetric predicate.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-TRANSITIVE-PREDICATE?"></a>function <tt><b>TRANSITIVE-PREDICATE?</b> : (predicate &amp;optional mt)</tt><br>
Return T iff PREDICATE is a transitive predicate.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-RELATION?"></a>function <tt><b>RELATION?</b> : (relation &amp;optional mt)</tt><br>
Return T iff RELATION is a relationship.<br>
Single value returned  satisfies BOOLEANP.<fn-def> 
<br>
<br>
<a name="FN-DEF-COMMUTATIVE-RELATION?"></a>function <tt><b>COMMUTATIVE-RELATION?</b> : (relation &amp;optional mt)</tt><br>
Return T iff RELATION is a commutative relation.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-COMMUTATIVE-FUNCTION?"></a>function <tt><b>COMMUTATIVE-FUNCTION?</b> : (function &amp;optional mt)</tt><br>
Return T iff FUNCTION is a commutative function.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-BINARY-PREDICATE?"></a>function <tt><b>BINARY-PREDICATE?</b> : (predicate &amp;optional mt)</tt><br>
Return T iff PREDICATE is a predicate of arity 2.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-ARGN-ISA"></a>function <tt><b>ARGN-ISA</b> : (relation argnum &amp;optional mt)</tt><br>
Returns a list of the local isa constraints applied to the ARGNUMth argument of <br>
RELATION (#$argsIsa conjoins with #$arg1Isa et al).<br>
 ARGNUM must satisfy INTEGERP.<fn-def>
<br>
<br>
<a name="FN-DEF-MIN-ARGN-ISA"></a>function <tt><b>MIN-ARGN-ISA</b> : (relation n &amp;optional mt)</tt><br>
Returns a list of the most specific local isa-constraints applicable <br>
to argument N of RELATION.<br>
 RELATION must satisfy INDEXED-TERM-P.<br>
 N must satisfy INTEGERP.<br>
Single value returned is a list of elements satisfying INDEXED-TERM-P.<fn-def>
<br>
<br>
<a name="FN-DEF-ARGN-ISA-OF"></a>function <tt><b>ARGN-ISA-OF</b> : (collection argnum &amp;optional mt)</tt><br>
Returns the relations for which COLLECTION is a <br>
local isa constraint applied to argument ARGNUM.<br>
 ARGNUM must satisfy INTEGERP.<br>
Single value returned is a list of elements satisfying INDEXED-TERM-P.<fn-def>
<br>
<br>
<a name="FN-DEF-ARGN-GENL"></a>function <tt><b>ARGN-GENL</b> : (relation argnum &amp;optional mt)</tt><br>
Returns the local genl constraints applied to the ARGNUMth argument of RELATION.<br>
 ARGNUM must satisfy INTEGERP.<br>
Single value returned is a list of elements satisfying INDEXED-TERM-P.<fn-def>
<br>
<br>
<a name="FN-DEF-MIN-ARGN-GENL"></a>function <tt><b>MIN-ARGN-GENL</b> : (relation n &amp;optional mt)</tt><br>
Return a list of the most specific local genl constraints applicable <br>
to the argument N of RELATION.<br>
 N must satisfy INTEGERP.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-ARGN-GENL-OF"></a>function <tt><b>ARGN-GENL-OF</b> : (collection argnum &amp;optional mt)</tt><br>
Returns a list of the predicates for which COLLECTION is a <br>
local genl constraint applied to the Nth argument.<br>
 ARGNUM must satisfy INTEGERP.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-DEFINING-DEFNS"></a>function <tt><b>DEFINING-DEFNS</b> : (col &amp;optional mt)</tt><br>
Return a list of the local defining (necessary and sufficient definitions) of collection COL.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-NECESSARY-DEFNS"></a>function <tt><b>NECESSARY-DEFNS</b> : (col &amp;optional mt)</tt><br>
Return a list of the local necessary definitions of collection COL.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-SUFFICIENT-DEFNS"></a>function <tt><b>SUFFICIENT-DEFNS</b> : (col &amp;optional mt)</tt><br>
Return a list of the local sufficient definitions of collection COL.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-ALL-SUFFICIENT-DEFNS"></a>function <tt><b>ALL-SUFFICIENT-DEFNS</b> : (col &amp;optional mt)</tt><br>
Return a list of all sufficient definitions of collection COL.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-ARITY"></a>function <tt><b>ARITY</b> : (relation &amp;optional mt)</tt><br>
Return the arity for relation constant RELATION.<fn-def>
<br>
<br>
<a name="FN-DEF-RESULT-ISA"></a>function <tt><b>RESULT-ISA</b> : (functor &amp;optional mt)</tt><br>
Return a list of the collections that include as instances <br>
the results of non-predicate function constant FUNCTOR.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-CREATOR"></a>function <tt><b>CREATOR</b> : (fort &amp;optional mt)</tt><br>
Identify the cyclist who created FORT.<br>
 FORT must satisfy FORT-P.<br>
 MT must satisfy HLMT-P.<br>
Single value returned  satisfies FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-CREATION-TIME"></a>function <tt><b>CREATION-TIME</b> : (fort &amp;optional mt)</tt><br>
Identify when FORT was created.<br>
 FORT must satisfy FORT-P.<br>
 MT must satisfy HLMT-P.<br>
Single value returned  satisfies INTEGERP.<fn-def>
<br>
<br>
<a name="FN-DEF-COMMENT"></a>function <tt><b>COMMENT</b> : (fort &amp;optional mt)</tt><br>
Return the comment string for FORT.<br>
 FORT must satisfy FORT-P.<br>
Single value returned  satisfies STRINGP.<fn-def>
<br>
<br>
<a name="FN-DEF-ASSERTED-BY"></a>function <tt><b>ASSERTED-BY</b> : (assertion)</tt><br>
Returns the cyclist who asserted ASSERTION.<br>
 ASSERTION must satisfy ASSERTION-P.<fn-def>
<br>
<br>
<a name="FN-DEF-ASSERTED-WHEN"></a>function <tt><b>ASSERTED-WHEN</b> : (assertion)</tt><br>
Returns the date when ASSERTION was asserted.<br>
 ASSERTION must satisfy ASSERTION-P.<br>
Single value returned  satisfies INTEGERP.<fn-def>
<br>
<br>
<a name="FN-DEF-REVIEWER"></a>function <tt><b>REVIEWER</b> : (fort &amp;optional mt)</tt><br>
Identify the cyclist who reviewed FORT.<br>
 FORT must satisfy FORT-P.<br>
 MT must satisfy HLMT-P.<br>
Single value returned  satisfies FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-ALL-TERM-ASSERTIONS"></a>function <tt><b>ALL-TERM-ASSERTIONS</b> : (term &amp;optional remove-duplicates?)</tt><br>
Return a list of all the assertions indexed via the indexed term TERM.<br>
 TERM must satisfy INDEXED-TERM-P.<br>
Single value returned is a list of elements satisfying ASSERTION-P.<fn-def>
<br>
<br>
<a name="FN-DEF-ISA-RELEVANT-ASSERTIONS"></a>function <tt><b>ISA-RELEVANT-ASSERTIONS</b> : (term &amp;optional mt)</tt><br>
Return a list of all (e.g., inheritance) rules relevant to TERM <br>
by virtue of the collections of which it is an instance.<br>
Single value returned is a list of elements satisfying ASSERTION-P.<fn-def>
<br>
<br>
<a name="FN-DEF-ASSERTIONS-MENTIONING-TERMS"></a>function <tt><b>ASSERTIONS-MENTIONING-TERMS</b> : (term-list &amp;optional include-meta-assertions?)</tt><br>
Return a list of assertions that mention every term in TERM-LIST.<br>
Single value returned is a list of elements satisfying ASSERTION-P.<fn-def>
<br>
<br>
<a name="FN-DEF-PRIMITIVE-COLLECTION?"></a>function <tt><b>PRIMITIVE-COLLECTION?</b> : (fort &amp;optional mt)</tt><br>
Return T iff FORT is a collection for which no classical (necessary and sufficient) <br>
definition is known.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-PREDS-FOR-PAIR"></a>function <tt><b>PREDS-FOR-PAIR</b> : (fort-1 fort-2 &amp;optional mt mode)</tt><br>
Return a list of the predicates relevant to relating FORT-1 and FORT-2.<br>
MODE may be :figurative (instances of collections), <br>
:literal (constants), or <br>
:mixed (referents).<br>
 FORT-1 must satisfy FORT-P.<br>
 FORT-2 must satisfy FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-COLLECTIONS-COEXTENSIONAL?"></a>function <tt><b>COLLECTIONS-COEXTENSIONAL?</b> : (col-1 col-2 &amp;optional mt)</tt><br>
Are COL-1 and COL-2 coextensional?<br>
 COL-1 must satisfy EL-FORT-P.<br>
 COL-2 must satisfy EL-FORT-P.<br>
Single value returned  satisfies BOOLEANP.<fn-def> 
<br>
<br>
<a name="FN-DEF-COLLECTIONS-DISJOINT?"></a>function <tt><b>COLLECTIONS-DISJOINT?</b> : (col-1 col-2 &amp;optional mt)</tt><br>
Are collections COL-1 and COL-2 disjoint?<br>
<code>   </code>(uses only sbhl graphs: their extensions are not searched<br>
<code>    </code>nor are their necessary conditions analyzed)<br>
 COL-1 must satisfy EL-FORT-P.<br>
 COL-2 must satisfy EL-FORT-P.<br>
Single value returned  satisfies BOOLEANP.<fn-def> 
<br>
<br>
<a name="FN-DEF-COLLECTIONS-INTERSECT?"></a>function <tt><b>COLLECTIONS-INTERSECT?</b> : (col-1 col-2 &amp;optional mt)</tt><br>
Do collections COL-1 and COL-2 intersect?<br>
<code>   </code>(uses only sbhl graphs: their extensions are not searched<br>
<code>    </code>nor are their sufficient conditions analyzed)<br>
 COL-1 must satisfy EL-FORT-P.<br>
 COL-2 must satisfy EL-FORT-P.<br>
Single value returned  satisfies BOOLEANP.<fn-def> 
<br>
<br>
<a name="FN-DEF-COUNT-ALL-INSTANCES"></a>function <tt><b>COUNT-ALL-INSTANCES</b> : (collection &amp;optional mt tv)</tt><br>
Counts the number of instances in the collection and then returns the count.<br>
 COLLECTION must satisfy EL-FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
 
<a name="Section-25"></a><h2>2.5 Epistemological-Level Support</h2>
<p>

Methods that support the EL

<br>
<br>
<a name="FN-DEF-EL-STRENGTH-P"></a>function <tt><b>EL-STRENGTH-P</b> : (object)</tt><br>
Return T iff OBJECT is a valid CycL assertion strength <br>
<code> </code>:default or :monotonic.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-EL-TO-HL"></a>function <tt><b>EL-TO-HL</b> : (formula &amp;optional mt)</tt><br>
Translate el expression FORMULA into its equivalent canonical hl expressions<br>
 FORMULA must satisfy EL-FORMULA-P.<fn-def>
<br>
<br>
<a name="FN-DEF-EL-TO-HL-QUERY"></a>function <tt><b>EL-TO-HL-QUERY</b> : (formula &amp;optional mt)</tt><br>
Translate el query FORMULA into its equivalent hl expressions<br>
 FORMULA must satisfy EL-FORMULA-P.<fn-def>
<br>
<br>
<a name="FN-DEF-ASSERTION-EL-FORMULA"></a>function <tt><b>ASSERTION-EL-FORMULA</b> : (assertion)</tt><br>
Return the el formula for ASSERTION<br>
 ASSERTION must satisfy ASSERTION-P.<br>
Single value returned  satisfies LISTP.<fn-def>
<br>
<br>
<a name="FN-DEF-EL-WFF-SYNTAX?"></a>function <tt><b>EL-WFF-SYNTAX?</b> : (formula &amp;optional mt)</tt><br>
Is FORMULA well-formed wrt syntax?<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-EL-WFF-SYNTAX+ARITY?"></a>function <tt><b>EL-WFF-SYNTAX+ARITY?</b> : (formula &amp;optional mt)</tt><br>
Is FORMULA well-formed wrt syntax and arity?<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-GROUND?"></a>function <tt><b>GROUND?</b> : (expression &amp;optional var?)</tt><br>
Returns whether EXPRESSION is free of any variables?<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-EL-FORMULA-OK?"></a>function <tt><b>EL-FORMULA-OK?</b> : (formula &amp;optional mt)</tt><br>
Is FORMULA a well-formed el formula?<br>
 FORMULA must satisfy LISTP.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-EL-QUERY-OK?"></a>function <tt><b>EL-QUERY-OK?</b> : (formula &amp;optional mt)</tt><br>
Is FORMULA a well-formed el query?<br>
 FORMULA must satisfy LISTP.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-DIAGNOSE-EL-FORMULA"></a>function <tt><b>DIAGNOSE-EL-FORMULA</b> : (formula &amp;optional mt io-mode)</tt><br>
Identify how el formula FORMULA fails syntactic or semantic constraints<br>
 FORMULA must satisfy LISTP.<fn-def>

<a name="Section-26"></a><h2>2.6 Transitivity HL Modules</h2>
<p>

Methods that support general transitivity reasoning using transitive
relations.


<a name="Section-261"></a><h3>2.6.1 Subsumption-Based HL Modules</h3>
<p>

Methods that provide support efficient transitivity reasoning over the
sbhl relations.

<a name="Section-2611"></a><h3>2.6.1.1 #$isa support</h3>
<no-newlines>
<a name="FN-DEF-MIN-ISA"></a>function <tt><b>MIN-ISA</b> : (term &amp;optional mt tv)</tt><br>
Returns most-specific collections that include TERM (inexpensive)<br>
 TERM must satisfy HL-TERM-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-MAX-NOT-ISA"></a>function <tt><b>MAX-NOT-ISA</b> : (term &amp;optional mt tv)</tt><br>
Returns most-general collections that do not include TERM (expensive)<br>
 TERM must satisfy HL-TERM-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-ALL-ISA"></a>function <tt><b>ALL-ISA</b> : (term &amp;optional mt tv)</tt><br>
Returns all collections that include TERM (inexpensive)<br>
 TERM must satisfy HL-TERM-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-UNION-ALL-ISA"></a>function <tt><b>UNION-ALL-ISA</b> : (terms &amp;optional mt tv)</tt><br>
Returns all collections that include any term in TERMS (inexpensive)<br>
 TERMS must satisfy LISTP.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-ALL-NOT-ISA"></a>function <tt><b>ALL-NOT-ISA</b> : (term &amp;optional mt tv)</tt><br>
Returns all collections that do not include TERM (expensive)<br>
 TERM must satisfy HL-TERM-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-ALL-INSTANCES"></a>function <tt><b>ALL-INSTANCES</b> : (col &amp;optional mt tv)</tt><br>
Returns all instances of COLLECTION (expensive)<br>
 COL must satisfy EL-FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-MAP-ALL-ISA"></a>function <tt><b>MAP-ALL-ISA</b> : (fn term &amp;optional mt tv)</tt><br>
Apply FUNCTION to every all-isa of TERM<br>
<code>   </code>(FUNCTION must not effect the current sbhl search state)<br>
 FN must satisfy FUNCTION-SPEC-P.<br>
 TERM must satisfy HL-TERM-P.<fn-def>
<br>
<br>
<a name="FN-DEF-ANY-WRT-ALL-ISA"></a>function <tt><b>ANY-WRT-ALL-ISA</b> : (function term &amp;optional mt tv)</tt><br>
Return the first encountered non-nil result of applying FUNCTION to the all-isa of TERM<br>
<code>   </code>(FUNCTION may not effect the current sbhl search state)<br>
 FUNCTION must satisfy FUNCTION-SPEC-P.<br>
 TERM must satisfy HL-TERM-P.<fn-def>
<br>
<br>
<a name="FN-DEF-MAP-ALL-INSTANCES"></a>function <tt><b>MAP-ALL-INSTANCES</b> : (fn col &amp;optional mt tv)</tt><br>
Apply FUNCTION to each unique instance of all specs of COLLECTION.<br>
 FN must satisfy FUNCTION-SPEC-P.<br>
 COL must satisfy EL-FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-MAP-INSTANCES"></a>function <tt><b>MAP-INSTANCES</b> : (function term &amp;optional mt tv)</tt><br>
apply FUNCTION to every (least general) #$isa of TERM<br>
 FUNCTION must satisfy FUNCTION-SPEC-P.<br>
 TERM must satisfy EL-FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-ISA?"></a>function <tt><b>ISA?</b> : (term collection &amp;optional mt tv)</tt><br>
Returns whether TERM is an instance of COLLECTION<br>
 COLLECTION must satisfy EL-FORT-P.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-ISA-ANY?"></a>function <tt><b>ISA-ANY?</b> : (term collections &amp;optional mt tv)</tt><br>
Returns whether TERM is an instance of any collection in COLLECTIONS<br>
 TERM must satisfy HL-TERM-P.<br>
 COLLECTIONS must satisfy LISTP.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-ANY-ISA-ANY?"></a>function <tt><b>ANY-ISA-ANY?</b> : (terms collections &amp;optional mt tv)</tt><br>
@return booleanp; whether any term in TERMS is an instance of any collection in COLLECTIONS<br>
 TERMS must satisfy LISTP.<br>
 COLLECTIONS must satisfy LISTP.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-NOT-ISA?"></a>function <tt><b>NOT-ISA?</b> : (term collection &amp;optional mt tv)</tt><br>
@return boolenap; whether TERM is known to not be an instance of COLLECTION<br>
 TERM must satisfy HL-TERM-P.<br>
 COLLECTION must satisfy EL-FORT-P.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-INSTANCES?"></a>function <tt><b>INSTANCES?</b> : (collection &amp;optional mt tv)</tt><br>
Returns whether COLLECTION has any direct instances<br>
 COLLECTION must satisfy EL-FORT-P.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-INSTANCES"></a>function <tt><b>INSTANCES</b> : (col &amp;optional mt tv)</tt><br>
Returns the asserted instances of COL<br>
 COL must satisfy EL-FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-ISA-SIBLINGS"></a>function <tt><b>ISA-SIBLINGS</b> : (term &amp;optional mt tv)</tt><br>
Returns the direct isas of those collections of which TERM is a direct instance<br>
 TERM must satisfy HL-TERM-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-MAX-FLOOR-MTS-OF-ISA-PATHS"></a>function <tt><b>MAX-FLOOR-MTS-OF-ISA-PATHS</b> : (term collection &amp;optional tv)</tt><br>
Returns in what (most-genl) mts TERM is an instance of COLLECTION<br>
 TERM must satisfy HL-TERM-P.<br>
 COLLECTION must satisfy EL-FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-WHY-ISA?"></a>function <tt><b>WHY-ISA?</b> : (term collection &amp;optional mt tv behavior)</tt><br>
Returns justification of (isa TERM COLLECTION)<br>
 TERM must satisfy HL-TERM-P.<br>
 COLLECTION must satisfy EL-FORT-P.<br>
Single value returned  satisfies LISTP.<fn-def>
<br>
<br>
<a name="FN-DEF-WHY-NOT-ISA?"></a>function <tt><b>WHY-NOT-ISA?</b> : (term collection &amp;optional mt tv behavior)</tt><br>
Returns justification of (not (isa TERM COLLECTION))<br>
 TERM must satisfy HL-TERM-P.<br>
 COLLECTION must satisfy EL-FORT-P.<br>
Single value returned  satisfies LISTP.<fn-def>
<br>
<br>
<a name="FN-DEF-ALL-INSTANCES-AMONG"></a>function <tt><b>ALL-INSTANCES-AMONG</b> : (col terms &amp;optional mt tv)</tt><br>
Returns those elements of TERMS that include COL as an all-isa<br>
 COL must satisfy HL-TERM-P.<br>
 TERMS must satisfy LISTP.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-ALL-ISA-AMONG"></a>function <tt><b>ALL-ISA-AMONG</b> : (term collections &amp;optional mt tv)</tt><br>
Returns those elements of COLLECTIONS that include TERM as an all-instance<br>
 TERM must satisfy HL-TERM-P.<br>
 COLLECTIONS must satisfy LISTP.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-ALL-ISAS-WRT"></a>function <tt><b>ALL-ISAS-WRT</b> : (term isa &amp;optional mt tv)</tt><br>
Returns all isa of term TERM that are also instances of collection ISA (ascending transitive closure; inexpensive)<br>
 TERM must satisfy EL-FORT-P.<br>
 ISA must satisfy EL-FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>  
<br>
<br>
<a name="FN-DEF-INSTANCE-SIBLINGS"></a>function <tt><b>INSTANCE-SIBLINGS</b> : (term &amp;optional mt tv)</tt><br>
Returns the direct instances of those collections having direct isa TERM<br>
 TERM must satisfy EL-FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>  
<br>
<br>
<a name="FN-DEF-MAX-INSTANCES"></a>function <tt><b>MAX-INSTANCES</b> : (col &amp;optional mt tv)</tt><br>
Returns the maximal among the asserted instances of COL<br>
 COL must satisfy EL-FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-MIN-NOT-INSTANCES"></a>function <tt><b>MIN-NOT-INSTANCES</b> : (col &amp;optional mt tv)</tt><br>
Returns the most-specific negated instances of collection COL<br>
 COL must satisfy EL-FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-NOT-ISA-AMONG"></a>function <tt><b>NOT-ISA-AMONG</b> : (term collections &amp;optional mt tv)</tt><br>
Returns those elements of COLLECTIONS that do NOT include TERM<br>
 TERM must satisfy HL-TERM-P.<br>
 COLLECTIONS must satisfy LISTP.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-UNION-ALL-INSTANCES"></a>function <tt><b>UNION-ALL-INSTANCES</b> : (cols &amp;optional mt tv)</tt><br>
Returns set of all instances of each collection in COLS (expensive)<br>
 COLS must satisfy LISTP.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def> 

<a name="Section-2612"></a><h3>2.6.1.2 #$genls support</h3>
<no-newlines>
<a name="FN-DEF-MIN-GENLS"></a>function <tt><b>MIN-GENLS</b> : (col &amp;optional mt tv)</tt><br>
Returns the most-specific genls of collection COL<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-MAX-NOT-GENLS"></a>function <tt><b>MAX-NOT-GENLS</b> : (col &amp;optional mt tv)</tt><br>
Returns the least-specific negated genls of collection COL<br>
 COL must satisfy EL-FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-MAX-SPECS"></a>function <tt><b>MAX-SPECS</b> : (col &amp;optional mt tv)</tt><br>
Returns the least-specific specs of collection COL<br>
 COL must satisfy EL-FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-MIN-NOT-SPECS"></a>function <tt><b>MIN-NOT-SPECS</b> : (col &amp;optional mt tv)</tt><br>
Returns the most-specific negated specs of collection COL<br>
 COL must satisfy EL-FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-GENL-SIBLINGS"></a>function <tt><b>GENL-SIBLINGS</b> : (col &amp;optional mt tv)</tt><br>
Returns the direct genls of those direct spec collections of COL<br>
 COL must satisfy EL-FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-SPEC-SIBLINGS"></a>function <tt><b>SPEC-SIBLINGS</b> : (col &amp;optional mt tv)</tt><br>
Returns the direct specs of those direct genls collections of COL<br>
 COL must satisfy EL-FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-ALL-GENLS"></a>function <tt><b>ALL-GENLS</b> : (col &amp;optional mt tv)</tt><br>
Returns all genls of collection COL<br>
<code>   </code>(ascending transitive closure; inexpensive)<br>
 COL must satisfy EL-FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-ALL-GENLS-WRT"></a>function <tt><b>ALL-GENLS-WRT</b> : (spec genl &amp;optional mt tv)</tt><br>
Returns all genls of collection SPEC that are also specs of collection GENL (ascending transitive closure; inexpensive)<br>
 SPEC must satisfy EL-FORT-P.<br>
 GENL must satisfy EL-FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-UNION-ALL-GENLS"></a>function <tt><b>UNION-ALL-GENLS</b> : (cols &amp;optional mt tv)</tt><br>
Returns all genls of each collection in COLs<br>
 COLS must satisfy LISTP.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-ALL-GENLS-IF"></a>function <tt><b>ALL-GENLS-IF</b> : (function col &amp;optional mt tv)</tt><br>
Returns all genls of collection COL that satisfy FUNCTION<br>
<code>   </code>(FUNCTION must not effect sbhl search state)<br>
 FUNCTION must satisfy FUNCTION-SPEC-P.<br>
 COL must satisfy EL-FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-ALL-NOT-GENLS"></a>function <tt><b>ALL-NOT-GENLS</b> : (col &amp;optional mt tv)</tt><br>
Returns all negated genls of collection COL <br>
<code>   </code>(descending transitive closure; expensive)<br>
 COL must satisfy EL-FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-ALL-SPECS"></a>function <tt><b>ALL-SPECS</b> : (col &amp;optional mt tv)</tt><br>
Returns all specs of collection COL <br>
<code>   </code>(descending transitive closure; expensive)<br>
 COL must satisfy EL-FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-ALL-SPECS-IF"></a>function <tt><b>ALL-SPECS-IF</b> : (function col &amp;optional mt tv)</tt><br>
Returns all genls of collection COL that satisfy FUNCTION<br>
<code>   </code>(FUNCTION must not effect sbhl search state)<br>
 FUNCTION must satisfy FUNCTION-SPEC-P.<br>
 COL must satisfy EL-FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-ALL-DEPENDENT-SPECS"></a>function <tt><b>ALL-DEPENDENT-SPECS</b> : (col &amp;optional mt tv)</tt><br>
Returns all specs s of COL s.t. every path connecting<br>
<code>   </code>s to any genl of COL must pass through COL<br>
 COL must satisfy EL-FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-UNION-ALL-SPECS"></a>function <tt><b>UNION-ALL-SPECS</b> : (cols &amp;optional mt tv)</tt><br>
Returns all specs of each collection in COLs<br>
 COLS must satisfy LISTP.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-GENL?"></a>function <tt><b>GENL?</b> : (spec genl &amp;optional mt tv)</tt><br>
Returns whether (#$genls SPEC GENL) can be inferred.<br>
<code>   </code>(ascending transitive search; inexpensive)<br>
 SPEC must satisfy EL-FORT-P.<br>
 GENL must satisfy EL-FORT-P.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-SPEC?"></a>function <tt><b>SPEC?</b> : (genl spec &amp;optional mt tv)</tt><br>
Returns whether (#$genls SPEC GENL) can be inferred.<br>
<code>   </code>(ascending transitive search; inexpensive)<br>
 GENL must satisfy EL-FORT-P.<br>
 SPEC must satisfy EL-FORT-P.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-ANY-GENL?"></a>function <tt><b>ANY-GENL?</b> : (spec genls &amp;optional mt tv)</tt><br>
(any-genl? spec genls) is t iff (genl? spec genl) for some genl in genls<br>
<code>   </code>(ascending transitive search; inexpensive)<br>
 SPEC must satisfy EL-FORT-P.<br>
 GENLS must satisfy LISTP.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-ALL-GENL?"></a>function <tt><b>ALL-GENL?</b> : (spec genls &amp;optional mt tv)</tt><br>
Returns T iff (genl? spec genl) for every genl in GENLS<br>
<code>   </code>(ascending transitive search; inexpensive)<br>
 SPEC must satisfy EL-FORT-P.<br>
 GENLS must satisfy LISTP.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-ANY-SPEC?"></a>function <tt><b>ANY-SPEC?</b> : (genl specs &amp;optional mt tv)</tt><br>
Returns T iff (spec? genl spec) for some spec in SPECS<br>
 GENL must satisfy EL-FORT-P.<br>
 SPECS must satisfy LISTP.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-ALL-SPEC?"></a>function <tt><b>ALL-SPEC?</b> : (genl specs &amp;optional mt tv)</tt><br>
Returns T iff (spec? genl spec) for every spec in SPECS<br>
 GENL must satisfy EL-FORT-P.<br>
 SPECS must satisfy LISTP.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-ANY-GENL-ANY?"></a>function <tt><b>ANY-GENL-ANY?</b> : (specs genls &amp;optional mt tv)</tt><br>
Return T iff (genl? spec genl mt) for any spec in SPECS, genl in GENLS<br>
 SPECS must satisfy LISTP.<br>
 GENLS must satisfy LISTP.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-ANY-GENL-ALL?"></a>function <tt><b>ANY-GENL-ALL?</b> : (specs genls &amp;optional mt tv)</tt><br>
Return T iff (genl? spec genl mt) for any spec in SPECS and all genl in GENLS<br>
 SPECS must satisfy LISTP.<br>
 GENLS must satisfy LISTP.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-NOT-GENL?"></a>function <tt><b>NOT-GENL?</b> : (col not-genl &amp;optional mt tv)</tt><br>
Return whether collection NOT-GENL is not a genl of COL.<br>
 COL must satisfy EL-FORT-P.<br>
 NOT-GENL must satisfy EL-FORT-P.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-ANY-NOT-GENL?"></a>function <tt><b>ANY-NOT-GENL?</b> : (col not-genls &amp;optional mt tv)</tt><br>
Returns whether any collection in NOT-GENLS is not a genl of COL.<br>
 COL must satisfy EL-FORT-P.<br>
 NOT-GENLS must satisfy LISTP.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-COLLECTION-LEAVES"></a>function <tt><b>COLLECTION-LEAVES</b> : (col &amp;optional mt tv)</tt><br>
Returns the minimally-general (the most specific) among all-specs of COL<br>
 COL must satisfy EL-FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-MIN-COLS"></a>function <tt><b>MIN-COLS</b> : (cols &amp;optional mt tv)</tt><br>
Returns the minimally-general (the most specific) among reified collections COLS<br>
 COLS must satisfy LISTP.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-MAX-COLS"></a>function <tt><b>MAX-COLS</b> : (cols &amp;optional mt tv)</tt><br>
Returns the most-general among reified collections COLS<br>
 COLS must satisfy LISTP.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-MIN-CEILING-COLS"></a>function <tt><b>MIN-CEILING-COLS</b> : (cols &amp;optional candidates mt tv)</tt><br>
Returns the most specific common generalizations among reified collections COLS<br>
<code>   </code>(if CANDIDATES is non-nil, then result is a subset of CANDIDATES)<br>
 COLS must satisfy LISTP.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-MAX-FLOOR-COLS"></a>function <tt><b>MAX-FLOOR-COLS</b> : (cols &amp;optional candidates mt tv)</tt><br>
Returns the most general common specializations among reified collections COLS<br>
<code>   </code>(if CANDIDATES is non-nil, then result is a subset of CANDIDATES)<br>
 COLS must satisfy LISTP.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-ANY-DISJOINT-COLLECTION-PAIR"></a>function <tt><b>ANY-DISJOINT-COLLECTION-PAIR</b> : (cols &amp;optional mt)</tt><br>
Returns a pair of disjoint elements of COLS (if any exist)<br>
 COLS must satisfy LISTP.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-ANY-DISJOINT-COLLECTION-PAIR?"></a>function <tt><b>ANY-DISJOINT-COLLECTION-PAIR?</b> : (cols &amp;optional mt)</tt><br>
Are any two collections in COLS disjoint?<br>
 COLS must satisfy LISTP.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-WHY-COLLECTIONS-DISJOINT?"></a>function <tt><b>WHY-COLLECTIONS-DISJOINT?</b> : (c1 c2 &amp;optional mt)</tt><br>
Justification of (disjointWith C1 C2)<br>
 C1 must satisfy EL-FORT-P.<br>
 C2 must satisfy EL-FORT-P.<br>
Single value returned  satisfies LISTP.<fn-def>  
<br>
<br>
<a name="FN-DEF-ANY-GENL-ISA"></a>function <tt><b>ANY-GENL-ISA</b> : (col isa &amp;optional mt tv)</tt><br>
Return some genl of COL that isa instance of ISA (if any such genl exists)<br>
 COL must satisfy EL-FORT-P.<br>
 ISA must satisfy EL-FORT-P.<br>
Single value returned  satisfies FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-LIGHTER-COL"></a>function <tt><b>LIGHTER-COL</b> : (col-a col-b)</tt><br>
Return COL-B iff it has fewer specs than COL-A, else return COL-A<br>
 COL-A must satisfy EL-FORT-P.<br>
 COL-B must satisfy EL-FORT-P.<br>
Single value returned  satisfies FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-SHALLOWER-COL"></a>function <tt><b>SHALLOWER-COL</b> : (col-a col-b)</tt><br>
Return COL-B iff it has fewer genls than COL-A, else return COL-A<br>
 COL-A must satisfy EL-FORT-P.<br>
 COL-B must satisfy EL-FORT-P.<br>
Single value returned  satisfies FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-MAX-FLOOR-MTS-OF-GENLS-PATHS"></a>function <tt><b>MAX-FLOOR-MTS-OF-GENLS-PATHS</b> : (spec genl &amp;optional tv)</tt><br>
@return listp; Returns in what (most-genl) mts GENL is a genls of SPEC<br>
 SPEC must satisfy EL-FORT-P.<br>
 GENL must satisfy EL-FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-WHY-NOT-ASSERT-GENLS?"></a>function <tt><b>WHY-NOT-ASSERT-GENLS?</b> : (spec genl &amp;optional mt)</tt><br>
Justification of why asserting (genls SPEC GENL) is not consistent<br>
 SPEC must satisfy EL-FORT-P.<br>
 GENL must satisfy EL-FORT-P.<br>
Single value returned  satisfies LISTP.<fn-def>
<br>
<br>
<a name="FN-DEF-MAP-ALL-GENLS"></a>function <tt><b>MAP-ALL-GENLS</b> : (fn col &amp;optional mt tv)</tt><br>
Applies FN to every (all) genls of COL<br>
<code>   </code>(FN must not effect the current sbhl space)<br>
 FN must satisfy FUNCTION-SPEC-P.<br>
 COL must satisfy EL-FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-ANY-ALL-GENLS"></a>function <tt><b>ANY-ALL-GENLS</b> : (fn col &amp;optional mt tv)</tt><br>
Return a non-nil result of applying FN to some all-genl of COL<br>
<code>   </code>(FN must not effect the current sbhl space)<br>
 FN must satisfy FUNCTION-SPEC-P.<br>
 COL must satisfy EL-FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-MAP-ALL-SPECS"></a>function <tt><b>MAP-ALL-SPECS</b> : (fn col &amp;optional mt tv)</tt><br>
Applies FN to every (all) specs of COL<br>
<code>   </code>(FN must not effect the current sbhl space)<br>
 FN must satisfy FUNCTION-SPEC-P.<br>
 COL must satisfy EL-FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-ANY-ALL-SPECS"></a>function <tt><b>ANY-ALL-SPECS</b> : (fn col &amp;optional mt tv)</tt><br>
Return a non-nil result of applying FN to some all-spec of COL<br>
<code>   </code>(FN must not effect the current sbhl space)<br>
 FN must satisfy FUNCTION-SPEC-P.<br>
 COL must satisfy EL-FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-ALL-GENLS-AMONG"></a>function <tt><b>ALL-GENLS-AMONG</b> : (col candidates &amp;optional mt tv)</tt><br>
Returns those genls of COL that are included among CANDIDATEs<br>
 COL must satisfy EL-FORT-P.<br>
 CANDIDATES must satisfy LISTP.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-ALL-NOT-SPEC?"></a>function <tt><b>ALL-NOT-SPEC?</b> : (col not-specs &amp;optional mt tv)</tt><br>
Return whether every collection in NOT-SPECS is not a spec of COL.<br>
 COL must satisfy EL-FORT-P.<br>
 NOT-SPECS must satisfy LISTP.<br>
Single value returned  satisfies BOOLEANP.<fn-def> 
<br>
<br>
<a name="FN-DEF-ALL-NOT-SPECS"></a>function <tt><b>ALL-NOT-SPECS</b> : (col &amp;optional mt tv)</tt><br>
Returns all negated specs of collection COL <br>
<code>   </code>(ascending transitive closure; inexpensive)<br>
 COL must satisfy EL-FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-ALL-SPEC-ANY?"></a>function <tt><b>ALL-SPEC-ANY?</b> : (specs genls &amp;optional mt tv)</tt><br>
Return T iff for each spec in SPECS there is some genl in GENLS s.t. (genl? spec genl mt)<br>
 SPECS must satisfy LISTP.<br>
 GENLS must satisfy LISTP.<br>
Single value returned  satisfies BOOLEANP.<fn-def> 
<br>
<br>
<a name="FN-DEF-ALL-SPECS-AMONG"></a>function <tt><b>ALL-SPECS-AMONG</b> : (col candidates &amp;optional mt tv)</tt><br>
Returns those specs of COL that are included among CANDIDATEs<br>
 COL must satisfy EL-FORT-P.<br>
 CANDIDATES must satisfy LISTP.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-SPEC-SIBLINGS"></a>function <tt><b>SPEC-SIBLINGS</b> : (col &amp;optional mt tv)</tt><br>
Returns the direct specs of those direct genls collections of COL<br>
 COL must satisfy EL-FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-WHY-GENL?"></a>function <tt><b>WHY-GENL?</b> : (spec genl &amp;optional mt tv behavior)</tt><br>
Justification of (genls SPEC GENL)<br>
 SPEC must satisfy EL-FORT-P.<br>
 GENL must satisfy EL-FORT-P.<br>
Single value returned  satisfies LISTP.<fn-def> 
<br>
<br>
<a name="FN-DEF-WHY-NOT-GENL?"></a>function <tt><b>WHY-NOT-GENL?</b> : (spec genl &amp;optional mt tv behavior)</tt><br>
Justification of (not (genls SPEC GENL))<br>
 SPEC must satisfy EL-FORT-P.<br>
 GENL must satisfy EL-FORT-P.<br>
Single value returned  satisfies LISTP.<fn-def>

<a name="Section-2613"></a><h3>2.6.1.3 #$genlPreds and #$genlInverse support</h3>
<no-newlines>
<a name="FN-DEF-MIN-GENL-PREDICATES"></a>function <tt><b>MIN-GENL-PREDICATES</b> : (pred &amp;optional mt tv)</tt><br>
Returns the most-specific local genlPreds of PRED<br>
 PRED must satisfy FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-MIN-GENL-INVERSES"></a>function <tt><b>MIN-GENL-INVERSES</b> : (pred &amp;optional mt tv)</tt><br>
Returns the most-specific local genlInverses of PRED<br>
 PRED must satisfy FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-MAX-NOT-GENL-PREDICATES"></a>function <tt><b>MAX-NOT-GENL-PREDICATES</b> : (pred &amp;optional mt tv)</tt><br>
Returns the most-general local negated genlPreds of PRED<br>
 PRED must satisfy FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-MAX-NOT-GENL-INVERSES"></a>function <tt><b>MAX-NOT-GENL-INVERSES</b> : (pred &amp;optional mt tv)</tt><br>
Returns the most-general local negated genlPreds of PRED<br>
 PRED must satisfy FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-MAX-SPEC-PREDICATES"></a>function <tt><b>MAX-SPEC-PREDICATES</b> : (pred &amp;optional mt tv)</tt><br>
Returns the most-general specPreds of PRED<br>
 PRED must satisfy FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-MAX-SPEC-INVERSES"></a>function <tt><b>MAX-SPEC-INVERSES</b> : (pred &amp;optional mt tv)</tt><br>
Returns the most-general specInverses of PRED<br>
 PRED must satisfy FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-MIN-NOT-SPEC-PREDICATES"></a>function <tt><b>MIN-NOT-SPEC-PREDICATES</b> : (pred &amp;optional mt tv)</tt><br>
Returns the most-specific negated specPreds of PRED<br>
 PRED must satisfy FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-MIN-NOT-SPEC-INVERSES"></a>function <tt><b>MIN-NOT-SPEC-INVERSES</b> : (pred &amp;optional mt tv)</tt><br>
Returns the most-specific negated specPreds of PRED<br>
 PRED must satisfy FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-GENL-PREDICATE-SIBLINGS"></a>function <tt><b>GENL-PREDICATE-SIBLINGS</b> : (pred &amp;optional mt tv)</tt><br>
Returns the direct #$genlPreds of those predicates having direct spec-preds PRED<br>
 PRED must satisfy FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-GENL-INVERSE-SIBLINGS"></a>function <tt><b>GENL-INVERSE-SIBLINGS</b> : (pred &amp;optional mt tv)</tt><br>
Returns the direct #$genlInverse of those predicates having direct spec-inverses PRED<br>
 PRED must satisfy FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-SPEC-PREDICATE-SIBLINGS"></a>function <tt><b>SPEC-PREDICATE-SIBLINGS</b> : (pred &amp;optional mt tv)</tt><br>
Returns the direct spec-preds of those collections having direct #$genlPreds PRED<br>
 PRED must satisfy FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-SPEC-INVERSE-SIBLINGS"></a>function <tt><b>SPEC-INVERSE-SIBLINGS</b> : (pred &amp;optional mt tv)</tt><br>
Returns the direct spec-inverses of those collections having direct #$genlInverse PRED<br>
 PRED must satisfy FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-ALL-GENL-PREDICATES"></a>function <tt><b>ALL-GENL-PREDICATES</b> : (pred &amp;optional mt tv)</tt><br>
Returns all genlPreds of predicate PRED <br>
<code>   </code>(ascending transitive closure; inexpensive)<br>
 PRED must satisfy FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-ALL-GENL-INVERSES"></a>function <tt><b>ALL-GENL-INVERSES</b> : (pred &amp;optional mt tv)</tt><br>
Returns all genlPreds of predicate PRED <br>
<code>   </code>(ascending transitive closure; inexpensive)<br>
 PRED must satisfy FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-ALL-NOT-GENL-PREDICATES"></a>function <tt><b>ALL-NOT-GENL-PREDICATES</b> : (pred &amp;optional mt tv)</tt><br>
Returns all negated genlPreds of predicate PRED <br>
<code>   </code>(descending transitive closure; expensive)<br>
 PRED must satisfy FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-ALL-NOT-GENL-INVERSES"></a>function <tt><b>ALL-NOT-GENL-INVERSES</b> : (pred &amp;optional mt tv)</tt><br>
Returns all negated genlPreds of predicate PRED <br>
<code>   </code>(descending transitive closure; expensive)<br>
 PRED must satisfy FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-ALL-SPEC-PREDICATES"></a>function <tt><b>ALL-SPEC-PREDICATES</b> : (pred &amp;optional mt tv)</tt><br>
Returns all predicates having PRED as a genlPred <br>
<code>   </code>(descending transitive closure; expensive)<br>
 PRED must satisfy FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-ALL-SPEC-INVERSES"></a>function <tt><b>ALL-SPEC-INVERSES</b> : (pred &amp;optional mt tv)</tt><br>
Returns all predicates having PRED as a genlInverse<br>
<code>   </code>(descending transitive closure; expensive)<br>
 PRED must satisfy FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-ALL-SPEC-PREDS-WRT-TYPE"></a>function <tt><b>ALL-SPEC-PREDS-WRT-TYPE</b> : (pred col arg &amp;optional mt tv)</tt><br>
Returns those all-spec-preds of PRED for which instances <br>
of COL are legal in arguments in position ARG<br>
 PRED must satisfy FORT-P.<br>
 COL must satisfy FORT-P.<br>
 ARG must satisfy INTEGERP.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-ALL-SPEC-PREDS-WRT-ARG"></a>function <tt><b>ALL-SPEC-PREDS-WRT-ARG</b> : (pred fort arg &amp;optional mt tv)</tt><br>
Returns those all-spec-preds of PRED for which FORT<br>
is legal as arguments in position ARG<br>
 PRED must satisfy FORT-P.<br>
 FORT must satisfy FORT-P.<br>
 ARG must satisfy INTEGERP.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-ALL-NOT-SPEC-PREDICATES"></a>function <tt><b>ALL-NOT-SPEC-PREDICATES</b> : (pred &amp;optional mt tv)</tt><br>
Returns all negated specPreds of predicate PRED <br>
<code>   </code>(ascending transitive closure; inexpensive)<br>
 PRED must satisfy FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-ALL-NOT-SPEC-INVERSES"></a>function <tt><b>ALL-NOT-SPEC-INVERSES</b> : (pred &amp;optional mt tv)</tt><br>
Returns all predicates having PRED as a negated genlInverse<br>
<code>   </code>(ascending transitive closure; inexpensive)<br>
 PRED must satisfy FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-SPEC-PREDICATE?"></a>function <tt><b>SPEC-PREDICATE?</b> : (genl spec &amp;optional mt tv)</tt><br>
Is GENL a genlPred of SPEC?<br>
<code>   </code>(ascending transitive search; inexpensive)<br>
 GENL must satisfy FORT-P.<br>
 SPEC must satisfy FORT-P.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-GENL-PREDICATE?"></a>function <tt><b>GENL-PREDICATE?</b> : (spec genl &amp;optional mt tv)</tt><br>
Is GENL a genlPred of SPEC?<br>
<code>   </code>(ascending transitive search; inexpensive)<br>
 SPEC must satisfy FORT-P.<br>
 GENL must satisfy FORT-P.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-GENL-INVERSE?"></a>function <tt><b>GENL-INVERSE?</b> : (spec genl &amp;optional mt tv)</tt><br>
Is GENL a genlInverse of SPEC?<br>
<code>   </code>(ascending transitive search; inexpensive)<br>
 SPEC must satisfy FORT-P.<br>
 GENL must satisfy FORT-P.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-SPEC-INVERSE?"></a>function <tt><b>SPEC-INVERSE?</b> : (genl spec &amp;optional mt tv)</tt><br>
Is GENL a genlInverse of SPEC?<br>
<code>   </code>(ascending transitive search; inexpensive)<br>
 SPEC must satisfy FORT-P.<br>
 GENL must satisfy FORT-P.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-ANY-GENL-PREDICATE?"></a>function <tt><b>ANY-GENL-PREDICATE?</b> : (spec genls &amp;optional mt tv)</tt><br>
Returns T iff (genl-predicate? SPEC GENL) for some genl in GENLS<br>
<code>   </code>(ascending transitive search; inexpensive)<br>
 SPEC must satisfy FORT-P.<br>
 GENLS must satisfy LISTP.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-NOT-GENL-PREDICATE?"></a>function <tt><b>NOT-GENL-PREDICATE?</b> : (spec not-genl &amp;optional mt tv)</tt><br>
Is NOT-GENL knwon to be not a genlPred of SPEC?<br>
<code>   </code>(descending transitive search; expensive)<br>
 SPEC must satisfy FORT-P.<br>
 NOT-GENL must satisfy FORT-P.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-NOT-GENL-INVERSE?"></a>function <tt><b>NOT-GENL-INVERSE?</b> : (spec not-genl &amp;optional mt tv)</tt><br>
Is NOT-GENL a negated genlInverse of SPEC?<br>
<code>   </code>(descending transitive search; expensive)<br>
 SPEC must satisfy FORT-P.<br>
 NOT-GENL must satisfy FORT-P.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-ANY-NOT-GENL-PREDICATE?"></a>function <tt><b>ANY-NOT-GENL-PREDICATE?</b> : (pred not-genls &amp;optional mt tv)</tt><br>
Is any predicate in NOT-GENLS not a genlPred of PRED?<br>
<code>   </code>(descending transitive search; expensive)<br>
 PRED must satisfy FORT-P.<br>
 NOT-GENLS must satisfy LISTP.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-INTERSECTING-PREDICATES?"></a>function <tt><b>INTERSECTING-PREDICATES?</b> : (pred1 pred2 &amp;optional mt)</tt><br>
Does the extension of PRED1 include some tuple in the extension of PRED2?<br>
 PRED1 must satisfy FORT-P.<br>
 PRED2 must satisfy FORT-P.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-WHY-GENL-PREDICATE?"></a>function <tt><b>WHY-GENL-PREDICATE?</b> : (spec genl &amp;optional mt tv behavior)</tt><br>
A justification of (genlPreds SPEC GENL)<br>
 SPEC must satisfy FORT-P.<br>
 GENL must satisfy FORT-P.<br>
Single value returned  satisfies LISTP.<fn-def>
<br>
<br>
<a name="FN-DEF-WHY-NOT-GENL-PREDICATE?"></a>function <tt><b>WHY-NOT-GENL-PREDICATE?</b> : (spec genl &amp;optional mt tv behavior)</tt><br>
A justification of (not (genlPreds SPEC GENL))<br>
 SPEC must satisfy FORT-P.<br>
 GENL must satisfy FORT-P.<br>
Single value returned  satisfies LISTP.<fn-def>
<br>
<br>
<a name="FN-DEF-WHY-GENL-INVERSE?"></a>function <tt><b>WHY-GENL-INVERSE?</b> : (pred genl-inverse &amp;optional mt tv behavior)</tt><br>
A justification of (genlInverse PRED GENL-INVERSE)<br>
 PRED must satisfy FORT-P.<br>
 GENL-INVERSE must satisfy FORT-P.<br>
Single value returned  satisfies LISTP.<fn-def>
<br>
<br>
<a name="FN-DEF-WHY-NOT-GENL-INVERSE?"></a>function <tt><b>WHY-NOT-GENL-INVERSE?</b> : (spec genl &amp;optional mt tv behavior)</tt><br>
A justification of (not (genlInverse SPEC GENL)<br>
 SPEC must satisfy FORT-P.<br>
 GENL must satisfy FORT-P.<br>
Single value returned  satisfies LISTP.<fn-def>
<br>
<br>
<a name="FN-DEF-MIN-PREDICATES"></a>function <tt><b>MIN-PREDICATES</b> : (preds &amp;optional mt tv)</tt><br>
Returns the most-specific predicates in PREDS<br>
 PREDS must satisfy LISTP.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-MAX-PREDICATES"></a>function <tt><b>MAX-PREDICATES</b> : (preds &amp;optional mt tv)</tt><br>
Returns the most-specific predicates in PREDS<br>
 PREDS must satisfy LISTP.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-MIN-CEILING-PREDICATES"></a>function <tt><b>MIN-CEILING-PREDICATES</b> : (preds &amp;optional candidates mt tv)</tt><br>
Returns the most-specific common generalizations (ceilings) of PREDS<br>
 PREDS must satisfy LISTP.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-MAX-FLOOR-PREDICATES"></a>function <tt><b>MAX-FLOOR-PREDICATES</b> : (preds &amp;optional candidates mt tv)</tt><br>
Returns the most-general common specializations (floors) of PREDS<br>
 PREDS must satisfy LISTP.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-MAX-FLOOR-MTS-OF-GENL-PREDICATE-PATHS"></a>function <tt><b>MAX-FLOOR-MTS-OF-GENL-PREDICATE-PATHS</b> : (spec genl &amp;optional tv)</tt><br>
@return listp; In what (most-genl) mts is GENL a genlPred of SPEC?<br>
 SPEC must satisfy FORT-P.<br>
 GENL must satisfy FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-MAX-FLOOR-MTS-OF-GENL-INVERSE-PATHS"></a>function <tt><b>MAX-FLOOR-MTS-OF-GENL-INVERSE-PATHS</b> : (spec genl-inverse &amp;optional tv)</tt><br>
In what (most-genl) mts is GENL-INVERSE a genlInverse of SPEC?<br>
 SPEC must satisfy FORT-P.<br>
 GENL-INVERSE must satisfy FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-MAP-ALL-GENL-PREDS"></a>function <tt><b>MAP-ALL-GENL-PREDS</b> : (pred fn &amp;optional mt tv)</tt><br>
Apply FN to each genlPred of PRED<br>
 PRED must satisfy FORT-P.<br>
 FN must satisfy FUNCTION-SPEC-P.<fn-def>
<br>
<br>
<a name="FN-DEF-SOME-ALL-GENL-PREDS"></a>function <tt><b>SOME-ALL-GENL-PREDS</b> : (pred fn &amp;optional mt tv)</tt><br>
Apply FN to each genlPred of PRED until FN returns a non-nil result<br>
 PRED must satisfy FORT-P.<br>
 FN must satisfy FUNCTION-SPEC-P.<fn-def>
<br>
<br>
<a name="FN-DEF-MAP-ALL-SPEC-PREDS"></a>function <tt><b>MAP-ALL-SPEC-PREDS</b> : (pred fn &amp;optional mt tv)</tt><br>
Apply FN to each genlPred of PRED<br>
 PRED must satisfy FORT-P.<br>
 FN must satisfy FUNCTION-SPEC-P.<fn-def>
<br>
<br>
<a name="FN-DEF-SOME-ALL-SPEC-PREDS"></a>function <tt><b>SOME-ALL-SPEC-PREDS</b> : (pred fn &amp;optional mt tv)</tt><br>
Apply FN to each genlPred of PRED until FN returns a non-nil result<br>
 PRED must satisfy FORT-P.<br>
 FN must satisfy FUNCTION-SPEC-P.<fn-def>
<br>
<br>
<a name="FN-DEF-ALL-GENL-PREDS-AMONG"></a>function <tt><b>ALL-GENL-PREDS-AMONG</b> : (pred candidates &amp;optional mt tv)</tt><br>
Returns those genlPreds of PRED that are included among CANDIDATEs<br>
 PRED must satisfy EL-FORT-P.<br>
 CANDIDATES must satisfy LISTP.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-GENL-PREDICATES"></a>function <tt><b>GENL-PREDICATES</b> : (pred &amp;optional mt tv)</tt><br>
Returns the local genlPreds of PRED<br>
 PRED must satisfy FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-GENL-INVERSES"></a>function <tt><b>GENL-INVERSES</b> : (pred &amp;optional mt tv)</tt><br>
Returns the local genlInverses of PRED<br>
 PRED must satisfy FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>  
<br>
<br>
<a name="FN-DEF-NOT-GENL-INVERSES"></a>function <tt><b>NOT-GENL-INVERSES</b> : (pred &amp;optional mt tv)</tt><br>
Returns the local negated genlPreds of PRED<br>
 PRED must satisfy FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>  
<br>
<br>
<a name="FN-DEF-NOT-GENL-PREDICATES"></a>function <tt><b>NOT-GENL-PREDICATES</b> : (pred &amp;optional mt tv)</tt><br>
Returns the local negated genlPreds of PRED<br>
 PRED must satisfy FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-NOT-SPEC-INVERSES"></a>function <tt><b>NOT-SPEC-INVERSES</b> : (pred &amp;optional mt tv)</tt><br>
Returns the most-specific negated specPreds of PRED<br>
 PRED must satisfy FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-NOT-SPEC-PREDICATES"></a>function <tt><b>NOT-SPEC-PREDICATES</b> : (pred &amp;optional mt tv)</tt><br>
Returns the negated specPreds of PRED<br>
 PRED must satisfy FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-SOME-ALL-GENL-INVERSES"></a>function <tt><b>SOME-ALL-GENL-INVERSES</b> : (pred fn &amp;optional mt tv)</tt><br>
Apply FN to each genlPred of PRED until FN returns a non-nil result<br>
 PRED must satisfy FORT-P.<br>
 FN must satisfy FUNCTION-SPEC-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-SPEC-INVERSES"></a>function <tt><b>SPEC-INVERSES</b> : (pred &amp;optional mt tv)</tt><br>
Returns the specInverses of PRED<br>
 PRED must satisfy FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-SPEC-PREDICATES"></a>function <tt><b>SPEC-PREDICATES</b> : (pred &amp;optional mt tv)</tt><br>
Returns the specPreds of PRED<br>
 PRED must satisfy FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-UNION-ALL-GENL-INVERSES"></a>function <tt><b>UNION-ALL-GENL-INVERSES</b> : (preds &amp;optional mt tv)</tt><br>
Returns all genl-inverses of each collection in Preds<br>
 PREDS must satisfy LISTP.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-UNION-ALL-GENL-PREDICATES"></a>function <tt><b>UNION-ALL-GENL-PREDICATES</b> : (preds &amp;optional mt tv)</tt><br>
Returns all genl-predicates of each collection in Preds<br>
 PREDS must satisfy LISTP.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-UNION-ALL-SPEC-INVERSES"></a>function <tt><b>UNION-ALL-SPEC-INVERSES</b> : (preds &amp;optional mt tv)</tt><br>
Returns all specs of each collection in Preds<br>
 PREDS must satisfy LISTP.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-UNION-ALL-SPEC-PREDICATES"></a>function <tt><b>UNION-ALL-SPEC-PREDICATES</b> : (preds &amp;optional mt tv)</tt><br>
Returns all spec-predicates of each collection in Preds<br>
 PREDS must satisfy LISTP.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def> 

<a name="Section-2614"></a><h3>2.6.1.4 General transitivity support</h3>

<br>
<br>
<a name="FN-DEF-GT-ALL-ACCESSIBLE"></a>function <tt><b>GT-ALL-ACCESSIBLE</b> : (predicate fort &amp;optional mt)</tt><br>
Returns all superiors and all inferiors of FORT via PREDICATE<br>
 PREDICATE must satisfy FORT-P.<br>
 FORT must satisfy FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-GT-ALL-DEPENDENT-INFERIORS"></a>function <tt><b>GT-ALL-DEPENDENT-INFERIORS</b> : (predicate fort &amp;optional mt)</tt><br>
Returns all inferiors i of FORT s.t. every path connecting i to <br>
<code>   </code>any superior of FORT must pass through FORT<br>
 PREDICATE must satisfy FORT-P.<br>
 FORT must satisfy FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-GT-ALL-INFERIORS"></a>function <tt><b>GT-ALL-INFERIORS</b> : (predicate fort &amp;optional mt)</tt><br>
Returns all inferiors of FORT via PREDICATE<br>
 PREDICATE must satisfy FORT-P.<br>
 FORT must satisfy FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-GT-ALL-SUPERIORS"></a>function <tt><b>GT-ALL-SUPERIORS</b> : (predicate fort &amp;optional mt)</tt><br>
Returns all superiors of FORT via PREDICATE<br>
 PREDICATE must satisfy FORT-P.<br>
 FORT must satisfy FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-GT-ANY-SUPERIOR-PATH"></a>function <tt><b>GT-ANY-SUPERIOR-PATH</b> : (predicate inferior superior &amp;optional mt)</tt><br>
Returns list of nodes connecting INFERIOR with SUPERIOR<br>
 PREDICATE must satisfy FORT-P.<br>
 INFERIOR must satisfy FORT-P.<br>
 SUPERIOR must satisfy FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-GT-CO-INFERIORS"></a>function <tt><b>GT-CO-INFERIORS</b> : (predicate fort &amp;optional mt)</tt><br>
Returns sibling direct-inferiors of direct-superiors of FORT via PREDICATE, excluding FORT itself<br>
 PREDICATE must satisfy FORT-P.<br>
 FORT must satisfy FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-GT-CO-SUPERIORS"></a>function <tt><b>GT-CO-SUPERIORS</b> : (predicate fort &amp;optional mt)</tt><br>
Returns sibling direct-superiors of direct-inferiors of FORT via PREDICATE, excluding FORT itself<br>
 PREDICATE must satisfy FORT-P.<br>
 FORT must satisfy FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-GT-COMPLETES-CYCLE?"></a>function <tt><b>GT-COMPLETES-CYCLE?</b> : (predicate fort1 fort2 &amp;optional mt)</tt><br>
Returns whether a transitive path connect FORT2 to FORT1, <br>
<code>   </code>or whether a transitive inverse path connect FORT1 to FORT2?<br>
 PREDICATE must satisfy FORT-P.<br>
 FORT1 must satisfy FORT-P.<br>
 FORT2 must satisfy FORT-P.<br>
Single value returned  satisfies BOOLEANP.<fn-def> 
<br>
<br>
<a name="FN-DEF-GT-COMPOSE-FN-ALL-INFERIORS"></a>function <tt><b>GT-COMPOSE-FN-ALL-INFERIORS</b> : (predicate fort fn &amp;optional combine-fn mt)</tt><br>
Apply fn to each inferior of FORT; <br>
<code>   </code>fn takes a fort as its only arg, and <br>
<code>   </code>it must not effect the search status of each fort it visits<br>
 PREDICATE must satisfy FORT-P.<br>
 FORT must satisfy FORT-P.<br>
 FN must satisfy FUNCTION-SPEC-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-GT-COMPOSE-FN-ALL-SUPERIORS"></a>function <tt><b>GT-COMPOSE-FN-ALL-SUPERIORS</b> : (predicate fort fn &amp;optional combine-fn mt)</tt><br>
Apply fn to each superior of FORT;<br>
<code>   </code>fn takes a fort as its only arg, and must not effect the search status of each<br>
<code>  </code>fort it visits<br>
 PREDICATE must satisfy FORT-P.<br>
 FORT must satisfy FORT-P.<br>
 FN must satisfy FUNCTION-SPEC-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-GT-COMPOSE-PRED-ALL-INFERIORS"></a>function <tt><b>GT-COMPOSE-PRED-ALL-INFERIORS</b> : (predicate fort compose-pred &amp;optional compose-index-arg compose-gather-arg mt)</tt><br>
Returns all nodes accessible by COMPOSE-PRED from each inferior of FORT along <br>
<code>  </code>transitive PREDICATE<br>
 PREDICATE must satisfy FORT-P.<br>
 FORT must satisfy FORT-P.<br>
 COMPOSE-PRED must satisfy PREDICATE-IN-ANY-MT?.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-GT-COMPOSE-PRED-ALL-SUPERIORS"></a>function <tt><b>GT-COMPOSE-PRED-ALL-SUPERIORS</b> : (predicate fort compose-pred &amp;optional compose-index-arg compose-gather-arg mt)</tt><br>
Returns all nodes accessible by COMPOSE-PRED from each superior of FORT along <br>
<code>  </code>transitive PREDICATE<br>
 PREDICATE must satisfy FORT-P.<br>
 FORT must satisfy FORT-P.<br>
 COMPOSE-PRED must satisfy PREDICATE-IN-ANY-MT?.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-GT-CYCLES?"></a>function <tt><b>GT-CYCLES?</b> : (predicate fort &amp;optional mt)</tt><br>
Returns whether FORT is accessible from itself by one or more PREDICATE gafs?<br>
 PREDICATE must satisfy FORT-P.<br>
 FORT must satisfy FORT-P.<br>
Single value returned  satisfies BOOLEANP.<fn-def> 
<br>
<br>
<a name="FN-DEF-GT-HAS-INFERIOR?"></a>function <tt><b>GT-HAS-INFERIOR?</b> : (predicate superior inferior &amp;optional mt)</tt><br>
Returns whether fort SUPERIOR is hierarchically higher <br>
<code>   </code>(wrt transitive PREDICATE) to fort INFERIOR?<br>
 PREDICATE must satisfy FORT-P.<br>
 SUPERIOR must satisfy FORT-P.<br>
 INFERIOR must satisfy FORT-P.<br>
Single value returned  satisfies BOOLEANP.<fn-def> 
<br>
<br>
<a name="FN-DEF-GT-HAS-SUPERIOR?"></a>function <tt><b>GT-HAS-SUPERIOR?</b> : (predicate inferior superior &amp;optional mt)</tt><br>
Returns whetherfort INFERIOR is hierarchically lower (wrt transitive PREDICATE) <br>
<code>  </code>to fort SUPERIOR?<br>
 PREDICATE must satisfy FORT-P.<br>
 INFERIOR must satisfy FORT-P.<br>
 SUPERIOR must satisfy FORT-P.<br>
Single value returned  satisfies BOOLEANP.<fn-def> 
<br>
<br>
<a name="FN-DEF-GT-INFERIORS"></a>function <tt><b>GT-INFERIORS</b> : (predicate fort &amp;optional mt)</tt><br>
Returns direct inferiors of FORT via transitive PREDICATE<br>
 PREDICATE must satisfy FORT-P.<br>
 FORT must satisfy FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-GT-LEAVES"></a>function <tt><b>GT-LEAVES</b> : (predicate fort &amp;optional mt)</tt><br>
Returns minimal inferiors (i.e., leaves) of FORT via PREDICATE<br>
 PREDICATE must satisfy FORT-P.<br>
 FORT must satisfy FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-GT-MAX-FLOORS"></a>function <tt><b>GT-MAX-FLOORS</b> : (predicate forts &amp;optional candidates mt)</tt><br>
Returns the least-subordinate elements or common inferiors of FORTS<br>
<code>   </code>(when CANDIDATES is non-nil, the result must subset it)<br>
 PREDICATE must satisfy FORT-P.<br>
 FORTS must satisfy LISTP.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-GT-MAX-INFERIORS"></a>function <tt><b>GT-MAX-INFERIORS</b> : (predicate fort &amp;optional mt)</tt><br>
Returns maximal inferiors of FORT via transitive PREDICATE<br>
 PREDICATE must satisfy FORT-P.<br>
 FORT must satisfy FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-GT-MAX-INFERIORS-EXCLUDING"></a>function <tt><b>GT-MAX-INFERIORS-EXCLUDING</b> : (predicate inferior superior &amp;optional mt)</tt><br>
Returns most-general inferiors of SUPERIOR ignoring INFERIOR (expensive)<br>
<code>   </code>(useful for splicing-out INFERIOR from hierarchy)<br>
 PREDICATE must satisfy FORT-P.<br>
 INFERIOR must satisfy FORT-P.<br>
 SUPERIOR must satisfy FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-GT-MAX-NODES"></a>function <tt><b>GT-MAX-NODES</b> : (predicate forts &amp;optional mt direction)</tt><br>
Returns returns the least-subordinate elements of FORTS<br>
<code>   </code>(&lt;direction&gt; should be :up unless all nodes are low in the hierarchy)<br>
 PREDICATE must satisfy FORT-P.<br>
 FORTS must satisfy LISTP.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-GT-MIN-CEILINGS"></a>function <tt><b>GT-MIN-CEILINGS</b> : (predicate forts &amp;optional candidates mt)</tt><br>
Returns the most-subordinate common superiors of FORTS<br>
<code>   </code>(when CANDIDATES is non-nil, the result must subset it)<br>
 PREDICATE must satisfy FORT-P.<br>
 FORTS must satisfy LISTP.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-GT-MIN-NODES"></a>function <tt><b>GT-MIN-NODES</b> : (predicate forts &amp;optional mt)</tt><br>
Returns returns the most-subordinate elements of FORTS<br>
<code>   </code>(one member only of a cycle will be a min-node candidate)<br>
 PREDICATE must satisfy FORT-P.<br>
 FORTS must satisfy LISTP.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-GT-MIN-SUPERIORS"></a>function <tt><b>GT-MIN-SUPERIORS</b> : (predicate fort &amp;optional mt)</tt><br>
Returns minimal superiors of FORT via transitive PREDICATE<br>
 PREDICATE must satisfy FORT-P.<br>
 FORT must satisfy FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-GT-MIN-SUPERIORS-EXCLUDING"></a>function <tt><b>GT-MIN-SUPERIORS-EXCLUDING</b> : (predicate inferior superior &amp;optional mt)</tt><br>
Returns least-general superiors of INFERIOR ignoring SUPERIOR<br>
<code>   </code>(useful for splicing-out SUPERIOR from hierarchy)<br>
 PREDICATE must satisfy FORT-P.<br>
 INFERIOR must satisfy FORT-P.<br>
 SUPERIOR must satisfy FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-GT-REDUNDANT-INFERIORS"></a>function <tt><b>GT-REDUNDANT-INFERIORS</b> : (predicate fort &amp;optional mt)</tt><br>
Returns direct-inferiors of FORT via PREDICATE that subsumed other inferiors<br>
 PREDICATE must satisfy FORT-P.<br>
 FORT must satisfy FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-GT-REDUNDANT-SUPERIORS"></a>function <tt><b>GT-REDUNDANT-SUPERIORS</b> : (predicate fort &amp;optional mt)</tt><br>
Returns direct-superiors of FORT via PREDICATE that are subsumed by other superiors<br>
 PREDICATE must satisfy FORT-P.<br>
 FORT must satisfy FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-GT-ROOTS"></a>function <tt><b>GT-ROOTS</b> : (predicate fort &amp;optional mt)</tt><br>
Returns maximal superiors (i.e., roots) of FORT via PREDICATE<br>
 PREDICATE must satisfy FORT-P.<br>
 FORT must satisfy FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-GT-SUPERIORS"></a>function <tt><b>GT-SUPERIORS</b> : (predicate fort &amp;optional mt)</tt><br>
Returns direct superiors of FORT via transitive PREDICATE<br>
 PREDICATE must satisfy FORT-P.<br>
 FORT must satisfy FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-GT-WHY-COMPLETES-CYCLE?"></a>function <tt><b>GT-WHY-COMPLETES-CYCLE?</b> : (predicate fort1 fort2 &amp;optional mt)</tt><br>
Returns justification that a transitive path connects FORT2 to FORT1, <br>
<code>   </code>or that a transitive inverse path connects FORT1 to FORT2?<br>
 PREDICATE must satisfy FORT-P.<br>
 FORT1 must satisfy FORT-P.<br>
 FORT2 must satisfy FORT-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-GT-WHY-SUPERIOR?"></a>function <tt><b>GT-WHY-SUPERIOR?</b> : (predicate superior inferior &amp;optional mt)</tt><br>
Returns justification of why SUPERIOR is superior to (i.e., hierarchically higher than) <br>
<code>  </code>INFERIOR<br>
 PREDICATE must satisfy FORT-P.<br>
 SUPERIOR must satisfy FORT-P.<br>
 INFERIOR must satisfy FORT-P.<br>
Single value returned is a list of elements satisfying ASSERTION-P.<fn-def>  

<a name="Section-2615"></a><h3>2.6.1.5 #$genlAttributes support</h3>

<br>
<br>
<a name="FN-DEF-ALL-GENL-ATTRIBUTES"></a>function <tt><b>ALL-GENL-ATTRIBUTES</b> : (att &amp;optional mt tv)</tt><br>
Returns all genl-attributes of attribute ATT<br>
<code>   </code>(ascending transitive closure; inexpensive)<br>
 ATT must satisfy EL-FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-ALL-GENL-ATTRIBUTES-IF"></a>function <tt><b>ALL-GENL-ATTRIBUTES-IF</b> : (function att &amp;optional mt tv)</tt><br>
Returns all genl-attributes of attribute ATT that satisfy FUNCTION<br>
<code>   </code>(FUNCTION must not effect sbhl search state)<br>
 FUNCTION must satisfy FUNCTION-SPEC-P.<br>
 ATT must satisfy EL-FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-ALL-GENL-ATTRIBUTES-WRT"></a>function <tt><b>ALL-GENL-ATTRIBUTES-WRT</b> : (spec genl &amp;optional mt tv)</tt><br>
Returns all genl-attributes of attribute SPEC that are also specs of attribute GENL (ascending transitive closure; inexpensive)<br>
 SPEC must satisfy EL-FORT-P.<br>
 GENL must satisfy EL-FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-ARGN-GENL-ATTRIBUTE"></a>function <tt><b>ARGN-GENL-ATTRIBUTE</b> : (relation n &amp;optional mt)</tt><br>
Returns the local genl-attribute constraints applied to the Nth argument of RELATION.<br>
 N must satisfy INTEGERP.<br>
Single value returned is a list of elements satisfying INDEXED-TERM-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-ARGN-GENL-ATTRIBUTE-OF"></a>function <tt><b>ARGN-GENL-ATTRIBUTE-OF</b> : (collection n &amp;optional mt)</tt><br>
Returns a list of the predicates for which COLLECTION is a <br>
local genl-attribute constraint applied to the Nth argument.<br>
 N must satisfy INTEGERP.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-MIN-ARGN-GENL-ATTRIBUTE"></a>function <tt><b>MIN-ARGN-GENL-ATTRIBUTE</b> : (relation n &amp;optional mt)</tt><br>
Return a list of the most specific local genl-attribute constraints applicable <br>
to the argument N of RELATION.<br>
 N must satisfy INTEGERP.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>  
<br>
<br>
<a name="FN-DEF-ALL-SPEC-ATTRIBUTES"></a>function <tt><b>ALL-SPEC-ATTRIBUTES</b> : (att &amp;optional mt tv)</tt><br>
Returns all spec-attributes of attribute ATT <br>
<code>   </code>(descending transitive closure; expensive)<br>
 ATT must satisfy EL-FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-ALL-SPEC-ATTRIBUTES-IF"></a>function <tt><b>ALL-SPEC-ATTRIBUTES-IF</b> : (function att &amp;optional mt tv)</tt><br>
Returns all genl-attributes of attribute ATT that satisfy FUNCTION<br>
<code>   </code>(FUNCTION must not effect sbhl search state)<br>
 FUNCTION must satisfy FUNCTION-SPEC-P.<br>
 ATT must satisfy EL-FORT-P.<br>
Single value returned is a list of elements satisfying FORT-P.<fn-def>  



<a name="Section-27"></a><h2>2.7 Inference Module</h2>
<p>

Methods for the inference engine to query and modify the knowledge base.  The FI- prefixed functions are deprecated.  

<br>
<br>
<a name="FN-DEF-FI-FIND"></a>function <tt><b>FI-FIND</b> : (name)</tt><br>
Return the constant indentified by the string NAME.<br>
Single value returned satisfies CONSTANT-P or is NIL.<fn-def>
<br>
<br>
<a name="FN-DEF-FI-COMPLETE"></a>function <tt><b>FI-COMPLETE</b> : (prefix &amp;optional case-sensitive?)</tt><br>
Return a list of constants whose name begins with PREFIX. The comparison is<br>
performed in a case-insensitive mode unless CASE-SENSITIVE? is non-nil.<br>
Single value returned is a list of elements satisfying CONSTANT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-FI-CREATE"></a>function <tt><b>FI-CREATE</b> : (name &amp;optional external-id)</tt><br>
Create a new constant with NAME.<br>
If EXTERNAL-ID is non-null it is used, otherwise a unique identifier is generated.<br>
Single value returned  satisfies CONSTANT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-FI-FIND-OR-CREATE"></a>function <tt><b>FI-FIND-OR-CREATE</b> : (name &amp;optional external-id)</tt><br>
Return constant with NAME if it is present.  <br>
If not present, then create constant with NAME, using EXTERNAL-ID if given.<br>
If EXTERNAL-ID is not given, generate a new one for the new constant.<br>
Single value returned  satisfies CONSTANT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-FI-KILL"></a>function <tt><b>FI-KILL</b> : (fort)</tt><br>
Kill FORT and all its uses from the KB.  If FORT is a microtheory, all assertions<br>
in that microtheory are removed.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-FI-RENAME"></a>function <tt><b>FI-RENAME</b> : (constant name)</tt><br>
Change name of CONSTANT to NAME. Return the constant if no error, otherwise return NIL.<br>
Single value returned satisfies CONSTANT-P or is NIL.<fn-def>
<br>
<br>
<a name="FN-DEF-FI-LOOKUP"></a>function <tt><b>FI-LOOKUP</b> : (formula mt)</tt><br>
Returns two values when looking up the EL FORMULA in the microtheory MT.  The<br>
first value returned is a list of HL formulas resulting from the canonicalization<br>
of the EL FORMULA.  The second value is T iff all the HL assertions were properly <br>
put into the KB.<br>
    Value 1 returned is a list of elements satisfying CONSP.<br>
    Value 2 returned satisfies BOOLEANP<fn-def>
<br>
<br>
<a name="FN-DEF-FI-ASSERT"></a>function <tt><b>FI-ASSERT</b> : (formula mt &amp;optional strength direction)</tt><br>
Assert the FORMULA in the specified MT.  STRENGTH is :default or :monotonic.<br>
DIRECTION is :forward or :backward.  GAF assertion direction defaults to :forward, and rule<br>
assertion direction defaults to :backward. Return T if there was no error.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-FI-UNASSERT"></a>function <tt><b>FI-UNASSERT</b> : (formula mt)</tt><br>
Remove the assertions canonicalized from FORMULA in the microtheory MT.<br>
Return T if the operation succeeded, otherwise return NIL.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-FI-EDIT"></a>function <tt><b>FI-EDIT</b> : (old-formula new-formula &amp;optional old-mt new-mt strength direction)</tt><br>
Unassert the assertions canonicalized from OLD-FORMULA in the microtheory OLD-MT.<br>
<code>   </code>Assert NEW-FORMULA in the specified NEW-MT.  <br>
<code>   </code>STRENGTH is :default or :monotonic.<br>
<code>   </code>DIRECTION is :forward or :backward.  <br>
<code>    </code>GAF assertion direction defaults to :forward.<br>
<code>    </code>Rule assertion direction defaults to :backward.<br>
<code>   </code>Return T if there was no error.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-FI-BLAST"></a>function <tt><b>FI-BLAST</b> : (formula mt)</tt><br>
Remove all arguments for the FORMULA within MT, including both those <br>
arguments resulting the direct assertion of the FORMULA, and <br>
those arguments supporting the FORMULA which were derived through inference.<br>
Return T if successful, otherwise return NIL.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-FI-ASK"></a>function <tt><b>FI-ASK</b> : (formula &amp;optional mt backchain number time depth)</tt><br>
Ask for bindings for free variables which will satisfy FORMULA within MT.<br>
If BACKCHAIN is NIL, no inference is performed.<br>
If BACKCHAIN is an integer, then at most that many backchaining steps using rules<br>
are performed.<br>
If BACKCHAIN is T, then inference is performed without limit on the number of<br>
backchaining steps when searching for bindings.<br>
If NUMBER is an integer, then at most that number of bindings are returned.<br>
If TIME is an integer, then at most TIME seconds are consumed by the search for<br>
bindings.<br>
If DEPTH is an integer, then the inference paths are limited to that number of<br>
total steps.<br>
Returns NIL if the operation had an error.  Otherwise returns a list of variable/<br>
binding pairs.  In the case where the FORMULA has no free variables, the form<br>
(((T . T))) is returned indicating that the gaf is either directly asserted in the<br>
KB, or that it can be derived via rules in the KB.<br>
Single value returned satisfies LISTP or is NIL.<fn-def>
<br>
<br>
<a name="FN-DEF-FI-CONTINUE-LAST-ASK"></a>function <tt><b>FI-CONTINUE-LAST-ASK</b> : (&amp;optional backchain number time depth reconsider-deep)</tt><br>
Continue the last ask that was performed with more resources.<br>
If BACKCHAIN is NIL, no inference is performed.<br>
If BACKCHAIN is an integer, then at most that many backchaining steps using rules<br>
are performed.<br>
If BACKCHAIN is T, then inference is performed without limit on the number of<br>
backchaining steps when searching for bindings.<br>
If NUMBER is an integer, then at most that number of bindings are returned.<br>
If TIME is an integer, then at most TIME seconds are consumed by the search for<br>
bindings.<br>
If DEPTH is an integer, then the inference paths are limited to that number of<br>
total steps.<br>
Returns NIL if the operation had an error.  Otherwise returns a list of variable/<br>
binding pairs.  In the case where the FORMULA has no free variables, the form<br>
(((T . T))) is returned indicating that the gaf is either directly asserted in the<br>
KB, or that it can be derived via rules in the KB.<br>
Single value returned satisfies LISTP or is NIL.<fn-def>
<br>
<br>
<a name="FN-DEF-FI-ASK-STATUS"></a>function <tt><b>FI-ASK-STATUS</b> : ()</tt><br>
Return a status as to how the last ask successfully completed regarding<br>
resource limits.  <br>
:EXHAUST if the search spaces was exhausted.<br>
:DEPTH if the search space was limited because some nodes were too deep.<br>
:NUMBER if the requested number of bindings was found without exceeding other limits.<br>
:TIME if the time alloted expired prior to exhausting the search space.<br>
Return NIL if there was no prior successful ask.<br>
Single value returned satisfies ATOM or is NIL.<fn-def>
<br>
<br>
<a name="FN-DEF-FI-TMS-RECONSIDER-FORMULA"></a>function <tt><b>FI-TMS-RECONSIDER-FORMULA</b> : (formula mt)</tt><br>
Reconsider all arguments for FORMULA within MT.  Return T if the<br>
operation succeeded, NIL if there was an error.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-FI-TMS-RECONSIDER-MT"></a>function <tt><b>FI-TMS-RECONSIDER-MT</b> : (mt)</tt><br>
Reconsider all arguments for all formulas within MT.  Return T if the<br>
operation succeeded, NIL if there was an error.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-FI-TMS-RECONSIDER-GAFS"></a>function <tt><b>FI-TMS-RECONSIDER-GAFS</b> : (term &amp;optional arg predicate mt)</tt><br>
Reconsider all arguments for all gaf formulas involving TERM.<br>
ARG optionally constrains gafs such that the TERM occupies a specific arg position.<br>
PREDICATE optionally constrains gafs such that the specifed PREDICATE<br>
occupies the arg0 position.<br>
MT optionally constrains gafs such that they must be included in the specific<br>
microtheory. <br>
Return T if the operation succeeded, NIL if there was an error.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-FI-TMS-RECONSIDER-TERM"></a>function <tt><b>FI-TMS-RECONSIDER-TERM</b> : (term &amp;optional mt)</tt><br>
Reconsider all arguments involving TERM.  <br>
If MT is provided, then only arguments in that microtheory are reconsidered.<br>
Return T if the operation succeeded, NIL if there was an error.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-FI-HYPOTHESIZE"></a>function <tt><b>FI-HYPOTHESIZE</b> : (formula mt &amp;optional name-prefix term-ids)</tt><br>
Cyc attempts to check if FORMULA is satisfiable in MT by 'hypothesizing'<br>
constants for the variables in FORMULA, substituting them into FORMULA,<br>
and asserting the new formula in MT.  If this would trigger a <br>
contradiction, then NIL is returned.  Otherwise a binding list of variable /<br>
constant pairs is returned, indicating the constants which were <br>
successfully 'hypothesized'.  The form (((T . T))) is returned if no new terms<br>
required creation for the assertion of FORMULA.<br>
NAME-PREFIX is a string which is used as a prefix for the name of each new<br>
constant hypothesized.  TERM-IDS is a list of variable / id pairs indicating<br>
that the specified id should be used when generating the constant for the variable<br>
in FORMULA.  If TERM-IDS is NIL, then unused ids are allocated for the new<br>
constants.<br>
Single value returned satisfies LISTP or is NIL.<fn-def>
<br>
<br>
<a name="FN-DEF-FI-PROVE"></a>function <tt><b>FI-PROVE</b> : (formula mt &amp;optional backchain number time depth)</tt><br>
Attempts to prove FORMULA is true in MT under the given resource constraints.<br>
BACKCHAIN, NUMBER, TIME and DEPTH function as described for FI-ASK.<br>
FORMULA is interpreted as follows:<br>
If FORMULA is of the form (#$implies [antecedant] [consequent]) then<br>
(1) free variables in [antecedant] are assumed to be universally<br>
quantified<br>
(2) remaining variables in [consequent] are assumed to be existentially<br>
quantified.<br>
Otherwise FORMULA is interpreted as (#$implies #$True FORMULA) and handled as the<br>
case above.<br>
It returns NIL or a list of arguments as described for FI-JUSTIFY.<br>
Single value returned satisfies (LIST LISTP) or is NIL.<fn-def>
<br>
<br>
<a name="FN-DEF-FI-GET-ERROR"></a>function <tt><b>FI-GET-ERROR</b> : ()</tt><br>
Return a description of the error resulting from the last FI operation.<br>
Single value returned satisfies ATOM or is NIL.<fn-def>
<br>
<br>
<a name="FN-DEF-FI-GET-WARNING"></a>function <tt><b>FI-GET-WARNING</b> : ()</tt><br>
Return a description of the warning resulting from the last FI operation.<br>
Single value returned satisfies ATOM or is NIL.<fn-def>

<br>
<br>
<a name="FN-DEF-CYC-FIND-OR-CREATE"></a>function <tt><b>CYC-FIND-OR-CREATE</b> : (name external-id)</tt><br>
Return constant with NAME if it is present.  <br>
<code>   </code>If not present, then create constant with NAME, using EXTERNAL-ID if given.<br>
<code>   </code>If EXTERNAL-ID is not given, generate a new one for the new constant.<br>
 NAME must satisfy VALID-CONSTANT-NAME.<br>
 EXTERNAL-ID must satisfy (NIL-OR CONSTANT-EXTERNAL-ID-P).<br>
Single value returned  satisfies CONSTANT-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-CYC-CREATE"></a>function <tt><b>CYC-CREATE</b> : (name external-id)</tt><br>
Create a new constant with id EXTERNAL-ID.<br>
<code>   </code>If NAME is anything other than :unnamed,<br>
<code>   </code>the new constant will be given the name NAME.<br>
 NAME must satisfy NEW-CONSTANT-NAME-SPEC-P.<br>
 EXTERNAL-ID must satisfy (NIL-OR CONSTANT-EXTERNAL-ID-P).<br>
Single value returned  satisfies CONSTANT-P.<fn-def>
<br>
<br>
<a name="FN-DEF-CYC-CREATE-NEW-EPHEMERAL"></a>function <tt><b>CYC-CREATE-NEW-EPHEMERAL</b> : (name)</tt><br>
Creates a new constant with name NAME, but makes<br>
<code>   </code>no effort to synchronize its external ID with<br>
<code>   </code>other Cyc images.  This is intended for constants<br>
<code>   </code>that will not be transmitted to other Cyc images.<br>
 NAME must satisfy NEW-CONSTANT-NAME-SPEC-P.<br>
Single value returned  satisfies CONSTANT-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-CYC-CREATE-NEW-PERMANENT"></a>function <tt><b>CYC-CREATE-NEW-PERMANENT</b> : (name)</tt><br>
Creates a new constant with name NAME, gives it a<br>
<code>   </code>permanent unique external ID, and adds the constant<br>
<code>   </code>creation operation to the transcript queue.<br>
 NAME must satisfy NEW-CONSTANT-NAME-SPEC-P.<br>
Single value returned  satisfies CONSTANT-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-CYC-KILL"></a>function <tt><b>CYC-KILL</b> : (fort)</tt><br>
Kill FORT and all its uses from the KB.  If FORT is a microtheory, all assertions<br>
<code>   </code>in that microtheory are removed.<br>
 FORT must satisfy FORT-P.<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-CYC-RECREATE"></a>function <tt><b>CYC-RECREATE</b> : (constant)</tt><br>
Doesn't unassert the bookkeeping info,<br>
<code>   </code>but it might actually move it, or change<br>
<code>   </code>its format somehow.<br>
 CONSTANT must satisfy CONSTANT-P.<br>
Single value returned  satisfies CONSTANT-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-CYC-RENAME"></a>function <tt><b>CYC-RENAME</b> : (constant name)</tt><br>
Change name of CONSTANT to NAME. Return the constant if no error, otherwise return NIL.<br>
 CONSTANT must satisfy CONSTANT-P.<br>
 NAME must satisfy VALID-CONSTANT-NAME.<br>
Single value returned satisfies CONSTANT-P or is NIL.<fn-def>
<br>
<br>
<a name="FN-DEF-CYC-MERGE"></a>function <tt><b>CYC-MERGE</b> : (kill-fort keep-fort)</tt><br>
Move asserted assertions on KILL-TERM onto KEEP-TERM before killing KILL-TERM.<br>
<code>   </code>@return fort-p; KEEP-FORT<br>
 KILL-FORT must satisfy FORT-P.<br>
 KEEP-FORT must satisfy FORT-P.<br>
Single value returned  satisfies FORT-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-CYC-ASSERT"></a>function <tt><b>CYC-ASSERT</b> : (sentence &amp;optional mt properties)</tt><br>
Assert SENTENCE in the specified MT.<br>
<code>   </code>properties; :strength el-strength-p (:default or :monotonic)<br>
<code>               </code>:direction direction-p  (:forward or :backward)<br>
<code>   </code>GAF assertion direction defaults to :forward, and rule<br>
<code>   </code>assertion direction defaults to :backward.<br>
<code>   </code>@return booleanp; t iff the assert succeeded.  If the assertion<br>
<code>   </code>already existed, it is considered a success.<br>
 SENTENCE must satisfy POSSIBLY-SENTENCE-P.<br>
 MT must satisfy (NIL-OR HLMT-P).<br>
 PROPERTIES must satisfy ASSERT-PROPERTIES-P.<br>
Single value returned  satisfies BOOLEANP.<fn-def>  
<br>
<br>
<a name="FN-DEF-CYC-UNASSERT"></a>function <tt><b>CYC-UNASSERT</b> : (sentence &amp;optional mt)</tt><br>
Remove the assertions canonicalized from FORMULA in the microtheory MT.<br>
<code>   </code>Return T if the operation succeeded, otherwise return NIL.<br>
 SENTENCE must satisfy POSSIBLY-SENTENCE-P.<br>
 MT must satisfy (NIL-OR HLMT-P).<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-CYC-EDIT"></a>function <tt><b>CYC-EDIT</b> : (old-sentence new-sentence &amp;optional old-mt new-mt properties)</tt><br>
Unassert OLD-SENTENCE in OLD-MT, and assert NEW-SENTENCE in the specified NEW-MT.<br>
<code>   </code>@see cyc-unassert and @xref cyc-assert<br>
 OLD-SENTENCE must satisfy POSSIBLY-SENTENCE-P.<br>
 NEW-SENTENCE must satisfy POSSIBLY-SENTENCE-P.<br>
 OLD-MT must satisfy (NIL-OR HLMT-P).<br>
 NEW-MT must satisfy (NIL-OR HLMT-P).<br>
Single value returned  satisfies BOOLEANP.<fn-def>
<br>
<br>
<a name="FN-DEF-CYC-QUERY"></a>function <tt><b>CYC-QUERY</b> : (sentence &amp;optional mt properties)</tt><br>
Query for bindings for free variables which will satisfy SENTENCE within MT.<br>
;;;{{{DOC<br>
<code>   </code>Properties: :backchain NIL or an integer or T<br>
<code>               </code>:number    NIL or an integer<br>
<code>               </code>:time      NIL or an integer<br>
<code>               </code>:depth     NIL or an integer<br>
<code>               </code>:conditional-sentence boolean<br>
<code>   </code>If :backchain is NIL, no backchaining is performed.<br>
<code>   </code>If :backchain is an integer, then at most that many backchaining steps using rules<br>
<code>   </code>are performed.<br>
<code>   </code>If :backchain is T, then inference is performed without limit on the number of<br>
<code>   </code>backchaining steps when searching for bindings.<br>
<code>   </code>If :number is an integer, then at most that number of bindings are returned.<br>
<code>   </code>If :time is an integer, then at most that many seconds are consumed by the search for<br>
<code>   </code>bindings.<br>
<code>   </code>If :depth is an integer, then the inference paths are limited to that number of<br>
<code>   </code>total steps.<br>
<code>   </code>Returns NIL if the operation had an error.  Otherwise returns a (possibly empty)<br>
<code>   </code>binding set.  In the case where the SENTENCE has no free variables,<br>
<code>   </code>the form (NIL), the empty binding set is returned, indicating that the gaf is either<br>
<code>   </code>directly asserted in the KB, or that it can be derived via rules in the KB.<br>
<code>   </code>If it fails to be proven, NIL will be returned.<br>
<code>   </code>The second return value indicates the reason why the query halted.<br>
<code>   </code>If SENTENCE is an implication, or an ist wrapped around an implication,<br>
<code>   </code>and the :conditional-sentence property is non-nil, cyc-query will attempt to<br>
<code>   </code>prove SENTENCE by reductio ad absurdum.<br>
;;;}}}EDOC<br>
 SENTENCE must satisfy POSSIBLY-SENTENCE-P.<br>
 MT must satisfy (NIL-OR HLMT-P).<br>
 PROPERTIES must satisfy QUERY-PROPERTIES-P.<br>
Single value returned  satisfies QUERY-RESULTS-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-CYC-CONTINUE-QUERY"></a>function <tt><b>CYC-CONTINUE-QUERY</b> : (&amp;optional query-id properties)</tt><br>
Continues a query started by @xref cyc-query.<br>
<code>   </code>If QUERY-ID is :last, the most recent query is continued.<br>
 QUERY-ID must satisfy QUERY-ID-P.<br>
 PROPERTIES must satisfy QUERY-PROPERTIES-P.<br>
Single value returned  satisfies QUERY-RESULTS-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-CYC-ADD-ARGUMENT"></a>function <tt><b>CYC-ADD-ARGUMENT</b> : (sentence cycl-supports &amp;optional mt properties verify-supports)</tt><br>
Tell Cyc to conclude SENTENCE (optionally in MT) based on the list of CYCL-SUPPORTS which should themselves be assertions or <br>
<code>   </code>otherwise valid for support-p. If VERIFY-SUPPORTS is non-nil, then this function will attempt to verify the list of supports <br>
<code>   </code>before making the assertion.<br>
<code>   </code>Properties: :direction :forward or :backward<br>
 SENTENCE must satisfy POSSIBLY-SENTENCE-P.<br>
 CYCL-SUPPORTS must satisfy LIST-OF-CYCL-SUPPORT-P.<br>
 MT must satisfy (NIL-OR HLMT-P).<br>
 PROPERTIES must satisfy ASSERT-PROPERTIES-P.<br>
 VERIFY-SUPPORTS must satisfy BOOLEANP.<br>
Single value returned  satisfies BOOLEANP.<fn-def> 
<br>
<br>
<a name="FN-DEF-CYC-REMOVE-ALL-ARGUMENTS"></a>function <tt><b>CYC-REMOVE-ALL-ARGUMENTS</b> : (sentence &amp;optional mt)</tt><br>
Remove all arguments for SENTENCE within MT, including both those <br>
<code>   </code>arguments resulting the direct assertion of SENTENCE, and <br>
<code>   </code>those arguments supporting SENTENCE which were derived through inference.<br>
<code>   </code>Return T if successful, otherwise return NIL.<br>
 SENTENCE must satisfy POSSIBLY-SENTENCE-P.<br>
 MT must satisfy (NIL-OR HLMT-P).<br>
Single value returned  satisfies BOOLEANP.<fn-def> 
<br>
<br>
<a name="FN-DEF-CYC-REMOVE-ARGUMENT"></a>function <tt><b>CYC-REMOVE-ARGUMENT</b> : (sentence cycl-supports &amp;optional mt)</tt><br>
Remove the argument for SENTENCE specified by CYCL-SUPPORTS.<br>
 SENTENCE must satisfy POSSIBLY-SENTENCE-P.<br>
 CYCL-SUPPORTS must satisfy LIST-OF-CYCL-SUPPORT-P.<br>
 MT must satisfy (NIL-OR HLMT-P).<br>
Single value returned  satisfies BOOLEANP.<fn-def> 
<br>
<br>
<a name="FN-DEF-CYC-REWRITE"></a>function <tt><b>CYC-REWRITE</b> : (source-fort target-fort)</tt><br>
'moves' all asserted arguments from SOURCE-FORT to TARGET-FORT<br>
<code>   </code>@return fort-p; TARGET-FORT<br>
 SOURCE-FORT must satisfy FORT-P.<br>
 TARGET-FORT must satisfy FORT-P.<br>
Single value returned  satisfies FORT-P.<fn-def> 
<br>
<br>
<a name="FN-DEF-CYC-TMS-RECONSIDER-SENTENCE"></a>function <tt><b>CYC-TMS-RECONSIDER-SENTENCE</b> : (sentence &amp;optional mt)</tt><br>
Reconsider all arguments for SENTENCE within MT.  Return T if the<br>
<code>   </code>operation succeeded, NIL if there was an error.<br>
 SENTENCE must satisfy POSSIBLY-SENTENCE-P.<br>
 MT must satisfy (NIL-OR HLMT-P).<br>
Single value returned  satisfies BOOLEANP.<fn-def> 


<!------------------------------------------------------------------------->
<hr><h1><a name="transport"></a>3. Transport Layer</h1>

There are two transport protocols; the first is a convenient but incomplete 
telnet-like protocol, which is described in detail below.  And the second is a
complete binary protocol, named CFASL for which the reference client implementation
is given by CfaslInputStream and CfaslOutputStream java classes.  The source code
for the reference java Cyc api client implementation is maintained at 
<A HREF="http://www.sourceforge.net/projects/opencyc">SourceForge</a>. 

<h2>3.1 TCP Ports</h2>

The Cyc server provides API services by binding two TCP ports
and accepting TCP connections at those ports.  The default
installation installs API servers accepting at ports 3601 (ASCII) 
and 3614 (CFASL).
The actual port numbers used can be specified at installation time.

<h2>3.1.1 TCP Port Security</h2>

The Cyc server does not provide secure tcp connections.  Consequently it should be 
installed behind a network firewall or local firewall.  Applications using Cyc should
reside within the firewalled network or on the same host as Cyc.  Remote access to Cyc should be performed using secure shell (SSH) to forward the ports Cyc uses, over an encrypted channel.  Cyc's built in HTTP server defaults to port 8088 which can be proxied
as a secure (HTTPS) internet service.

<h2>3.2 Establishing a connection</h2>

A client application establishs an API connection to a Cyc server by
opening a TCP connection to one of the API ports on the machine
running the Cyc server.  The socket established is used to communicate
API messages to Cyc and read results from Cyc.

<p>

For the default installation, a connection is thus established by
opening a TCP connection to port 3601 or 3614 of the machine running
the Cyc server.

<h2>3.3 Server Algorithm</h2>

Once the socket to be used for communication is established, the Cyc
API server goes into a loop performing the following steps in order
until the connection is closed :

<ul>
<li>input one API request from the socket</li>
<li>evaluate the request</li>
<li>output the result to the socket</li>
</ul>

The protocol of each step is described below for the ASCII communication mode.

<h2>3.4 ASCII Message protocols</h2>

All messages used to input an API request and output an API result are
ASCII text messages.  Input messages are sent from the client to the
socket and at the Cyc server read from its input stream for the
socket.  Output messages are sent from the Cyc server to its output
stream for the socket and are read from the socket by the client
application.

<p>

The Cyc server flushes its output stream for the socket after each
output message is sent in order to ensure the client application can
read a complete output message without blocking.

<p>

The client application is similary reminded to flush its socket after
each input message is sent in order to ensure the Cyc server can read
a complete input message without blocking.

<h3>3.4.1  Input message protocol</h3>

The default input message protocol is an ASCII text message which can
be read in from the socket using the SubL "read" protocol.  More
precisely, the SubL function READ is called on the input stream for
the socket in order to produce a SubL form.  This form represents the
request to be evaluated.

<p>

Each API request is thus a textual sequence of the form

<blockquote><pre>
( &lt;API function&gt; &lt;arg1&gt; ... &lt;argN&gt; ) &lt;whitespace&gt;
</pre></blockquote>

For example :

<blockquote><pre>
(constant-id #$Thing)
</pre></blockquote>

The arguments to an API request may themselves be API requests.  For
example :

<blockquote><pre>
(constant-id (find-constant "Thing"))
</pre></blockquote>

<h3>3.4.2  Evaluating an API request</h3>

The API request read in is evaluated according to the SubL "eval"
protocol.  More precisely, the SubL function EVAL is called on the
form in order to produce a single SubL result.  This result is
outputted using the output message protocol.  If a function returns
multiple values, only the first value is used, however the SubL
function MULTIPLE-VALUE-LIST can be used to gather multiple values
into a single list.

<p>

If an error condition occurs during evaluation, the evaluation is
aborted and a string representing the error condition is used as the
result of the evaluation.

<h3>3.4.3  Output message protocol</h3>

The default API output message protocol consists of two parts.  First,
a code is output indicating whether or not the API request succeeded
or generated an error.

<p>

The code output is either the textual sequence

<blockquote><pre>
200 &lt;whitespace&gt;
</pre></blockquote> 

for a successful evaluation, or the sequence

<blockquote><pre>
500 &lt;whitespace&gt;
</pre></blockquote> 

if an error occurred during evaluation.  This code can be used by the
client application to interpret the second part of the output
protocol.

<p>

Second, the result of the API request is output according to the SubL
"print" protocol.  More precisely, the SubL function PRINT is called
on the result of the evaluation.

<p>

Thus, the result will be a textual sequence of the form

<blockquote><pre>
&lt;API result&gt; &lt;whitespace&gt;
</pre></blockquote> 

<h2>3.5 Closing a connection</h2>

A client application closes an API connection to a Cyc server by
simply executing the API request

<blockquote><pre>
(api-quit) &lt;whitespace&gt;
</pre></blockquote> 

This will cause the Cyc server to halt the connection and close the
socket.

<h2>3.6 Multithreading</h2>

In Cyc's multithreaded implementation, each API connection spawns a 
separate thread which is completely dedicated to handling the API server 
connection.  When the connection is broken, the thread exits.  

<p>

Note that a consequence of using a multithreaded implementation is
that the Cyc process is always responsive to new TCP connections, and
modifications to the Cyc KB performed via the API server are always
reflected in future API connections.

<h2>3.7 Sample API session</h2>

As described above, the ASCII API protocol is telnet-like.  As a
result, one can in fact use 'telnet' or secure-shell to connect to a 
machine which is running a Cyc server that is providing API services.  
This is useful for debugging and remote administration. 

<p>

Below is a trace of a simple API server session via 'telnet' to a Cyc
server running on the machine foo.bar.com :

<blockquote><pre>
user@foo.bar.com ~$ telnet foo.bar.com 3601
Trying 207.207.8.15...
Connected to foo.bar.com.
Escape character is '^]'.
(fi-find "Fido")
200 NIL
(fi-create "Fido")
200 #$Fido
(fi-find "Fido")
200 #$Fido
(fi-assert '(#$isa #$Fido #$Dog) #$BaseKB)
200 T
(fi-ask '(#$isa #$Fido ?COL) #$BaseKB nil 2)
200 (((?COL . #$Dog)) ((?COL . #$DomesticPet)))
(fi-continue-last-ask nil 2)
200 (((?COL . #$DomesticatedAnimal)) ((?COL . #$TameAnimal)))
(fi-ask '(#$isa #$Fido #$Mammal) #$BaseKB nil 2)
200 (((T . T)))
(mapcar #'assertion-id (gather-arg-index #$Fido 1 #$isa #$BaseKB))
200 (664220)
(assertion-cnf (find-assertion-by-id 664220))
200 (NIL ((#$isa #$Fido #$Dog)))
(assertion-el-formula (find-assertion-by-id 664220))
200 (#$isa #$Fido #$Dog)
(fi-kill #$Fido)
200 T
(fi-find "Fido")
200 NIL
(api-quit)
Connection closed by foreign host.
</pre></blockquote>

<!------------------------------------------------------------------------->
<!-- Insert Glossary section here -->

<!------------------------------------------------------------------------->
<hr><h1><a name="appendix-a"></a>Appendix A : Glossary</h1>

<h3>arg</h3>
<p>
Represents the ordinal argument number in a CycL expression of the form (Arg0 Arg1 ... ArgN).  Arg 0 is distinguished as the predicate position.


<h3>argument</h3>
<p>

Is either a belief or a deduction that supports an assertion.  Curently a belief results from a direct assertion. So an assertion is supported by either the fact that it was asserted by a Cyclist, it is supported by one or more applications of a rule assertion.


<h3>ask</h3>
<p>

A facility for querying the KB, obtaining bindings for variables in CycL EL formulas.  Or obtaining confirmation that a ground formula is present in the KB.


<h3>assert</h3>
<p>

A facility for inputting facts and rules into the KB.  Also known as Tell in the KB literature.


<h3>assertion</h3>
<p>

A CycL formula with or without variables (see GAF), which is present in the KB either through direct input by a Cyclist or as a result of inference from other assertions.


<h3>body</h3>
<p>

In Lisp macros, the body is a sequence of statements which define the expansion of the macro call into an evaluatable Lisp expression.


<h3>characterp</h3>
<p>

A predicate function which returns T if and only if the single argument is a character type.


<h3>Constant</h3>
<p>

A unique symbol within the KB.  The meaning and usage of a Constant depends upon assertions containing it, within a particular microtheory.  Lower level tools require that constants have the prefix #$ as in #$BaseKB, #$Thing, #$Collection, #$isa and #$implies.


<h3>Cyc</h3>
<p>L

The declarative language of the Cyc System in which assertions are written.  CycL is derived from first-order predicate calculus, but includes many extensions to FOPC which enhance the expressiveness of the language.


<h3>deduction</h3>
<p>

A set of assertions which support a specific assertion.  Also known as a Justification in the KB literature.


<h3>direction</h3>
<p>

An inference attribute of an assertion. Value :forward means that at the time of assertion, the inference engine uses the new assertion with all existing rules in applicable microtheories to derive additional assertions.  Value :backward means that the the inference engine may use the new assertion to derive assertions when seeking bindings for an Ask operation. Rules default to :backward because they may otherwise potentially generate many uninteresting assertions.  Gafs default to :forward because forward inference serves to derive likely useful additional assertions in a limited manner. 


<h3>EL</h3>
<p>

An acronym for Epistemological Level which is a CycL representation optimized for human authoring and understanding.  The canonicalizer facility of the KB automatically translates input formulas in EL form into efficient Heuristic Level (HL) representation.  Likewise an uncanonicalizer facility generates EL formula from their HL counterpart representation.  For example the logical operator #$implies is used at the EL, but the KB converts implications to Conjunctive Normal Form (CNF) at the HL.


<h3>FI</h3>
<p>

An acronym for the Functional Interface which is a small set of powerful high-level API functions.  Remaining API functions provide efficient access to KB objects in particular situations.  FI covers constant/assertion creation and removal from the KB as well as queries. 


<h3>gaf</h3>
<p>

An acronym for Ground Atomic Formula which is an assertion without any variables.  Gafs form the great majority of KB assertions.  The Arg0 term in a gaf is the predicate.  


<h3>genl</h3>
<p>

A CycL predicate meaning the generalization relationship of a specific KB collection to a more general collection.


<h3>formula</h3>
<p>

A formula is an expression following CycL syntax.


<h3>fort</h3>
<p>

An acronym for First Order Reified Term which is defined to be either a constant, or a reified Non-Atomic Reified Term (NART).


<h3>function</h3>
<p>

In the API context, this is a either a built in SubL procedure or one defined using SubL definition facilities.


<h3>HL</h3>
<p>

An acronym for Heuristic Level which is the efficient interal representation of KB datastructures and the procedures for accessing them.  


<h3>hypothesize</h3>
<p>

A feature of the KB which allows a query to be answered by automatically instantiating any required constants.


<h3>id</h3>
<p>

A unique integer identifier for a KB item.

 
<h3>iff</h3>
<p>

If and only if.


<h3>indexed term</h3>
<p>

Those terms, arguments to CycL predicates or functions, which are suitable for indexing in the KB.  The great majority of KB terms are indexed.  Non indexed terms are primarily logical connectives, heavily used CycL predicates having alternate efficient access mechanisms, and unlikely query candidates such as numbers.


<h3>isa</h3>
<p>

A CycL predicate meaning membership in a collection.


<h3>KB</h3>
<p>

An acronym for Knowledge Base, specifically the Cyc server.


<h3>map</h3>
<p>

A SubL function which applies an argument SubL function over a set of objects, either to return a result or for a side-effect purpose.


<h3>macro</h3>
<p>

A SubL source code expansion facility.


<h3>mt</h3>
<p>

A acronym for Microtheory.


<h3>nart</h3>
<p>

A Non-Atomic Reified Term is a CycL term (argument to CycL predicate or function) which is neither a variable nor an atomic (one word) constant.  NARTs are are terms formed by applying a CycL function to its arguments. 


<h3>predicate</h3>
<p>

A CycL predicate is a term appearing in the Arg0 position of a GAF.  The purpose of CycL predicates is to contain the meaning of constant relationships.


<h3>prove</h3>
<p>

A KB query returning a list of supporting arguments for the given formula, if it can be proven within the specified resource constraints.


<h3>rule</h3>
<p>

A CycL formula containing variables whose EL representation begins with #$implies.  A rule has two parts, called its antecedent (left-hand side) and consequent (right-hand side).


<h3>search space</h3>
<p>

When performing a query operation, the search space denotes all the possible derived assertions, obtaining the total number of bindings for the query.  The inference engine explores the search space, seeking bindings in an efficient fashion, limited by the given resource constraints.


<h3>sense</h3>
<p>

At the HL, sense distinguishes either the positive (via :pos) or negative (via :neg) clauses of an assertion represented in Conjunctive Normal Form.


<h3>string</h3>
<p>

A SubL object consisting of a sequence of characters.


<h3>support</h3>
<p>

A KB support is circumstance (represented by a variety of HL datastructures) affecting the belief in a particular assertion.  Supports are linked to assertions via KB arguments.


<h3>strength</h3>
<p>

An assertion may have strength values from among the following: :default (true unless otherwise as an exception known to be false), :true (true because a user specifies it absolutely true), :unknown (truth value cannot be determined at this KB state).


<h3>tms</h3>
<p>

An acronym for Truth Maintenance System.  The KB facility whereby previously derived assertions are automatically unasserted when KB supports are removed.  TMS ensures a consistent KB when a supporting assertion is undone by the user.

<h3>truth</h3>
<p>

An assertion may have either the value :true or the value :false as its truth value.  The great majority of KB assertions have truth value :true.


<h3>truth value</h3>
<p>

A composite assertion attribute for strength and truth attribute combinations. The truth value :true-mon means absolutely true. The truth value :true-def means true unless otherwise known to be false.  The truth value :unknown means that the truth value is not known to be true and not known to be false.  The truth value :false-def means false unless otherwise known to be true.  And :false-mon means absolutely false.


<h3>variable</h3>
<p>

A type of CycL term appearing in rules standing for not-known-in-advance constants that satisfy the formula of a rule.  When used in a KB query, variables specify which bindings are sought by the inference engine.


<!------------------------------------------------------------------------->
<!-- Insert Glossary section here -->
<!------------------------------------------------------------------------->
<hr><h1><a name="appendix-b"></a>Appendix B : Index</h1>

<p>
<b>
<a href=#Index-A>A</a> |
<a href=#Index-B>B</a> |
<a href=#Index-C>C</a> |
<a href=#Index-D>D</a> |
<a href=#Index-E>E</a> |
<a href=#Index-F>F</a> |
<a href=#Index-G>G</a> |
<a href=#Index-H>H</a> |
<a href=#Index-I>I</a> |
<a href=#Index-J>J</a> |
<a href=#Index-K>K</a> |
<a href=#Index-L>L</a> |
<a href=#Index-M>M</a> |
<a href=#Index-N>N</a> |
<a href=#Index-O>O</a> |
<a href=#Index-P>P</a> |
<a href=#Index-Q>Q</a> |
<a href=#Index-R>R</a> |
<a href=#Index-S>S</a> |
<a href=#Index-T>T</a> |
<a href=#Index-U>U</a> |
<a href=#Index-V>V</a> |
<a href=#Index-W>W</a> |
<a href=#Index-X>X</a> |
<a href=#Index-Y>Y</a> |
<a href=#Index-Z>Z</a>
</b>

<a name=Index-A></a><h4> A </h4>

<br>
<a href="#FN-DEF-ALL-DEPENDENT-SPECS"><tt>ALL-DEPENDENT-SPECS</tt></a> function<index-fn-ref>
<br>
<a href="#FN-DEF-ALL-GENL-ATTRIBUTES"><tt>ALL-GENL-ATTRIBUTES</tt></a> function<index-fn-ref>
<br>
<a href="#FN-DEF-ALL-GENL-ATTRIBUTES-IF"><tt>ALL-GENL-ATTRIBUTES-IF</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ALL-GENL-ATTRIBUTES-WRT"><tt>ALL-GENL-ATTRIBUTES-WRT</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ALL-GENL-INVERSES"><tt>ALL-GENL-INVERSES</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ALL-GENL-PREDICATES"><tt>ALL-GENL-PREDICATES</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ALL-GENL-PREDS-AMONG"><tt>ALL-GENL-PREDS-AMONG</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ALL-GENL?"><tt>ALL-GENL?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ALL-GENLS"><tt>ALL-GENLS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ALL-GENLS-AMONG"><tt>ALL-GENLS-AMONG</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ALL-GENLS-IF"><tt>ALL-GENLS-IF</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ALL-GENLS-WRT"><tt>ALL-GENLS-WRT</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ALL-INSTANCES"><tt>ALL-INSTANCES</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ALL-INSTANCES-AMONG"><tt>ALL-INSTANCES-AMONG</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ALL-ISA"><tt>ALL-ISA</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ALL-ISA-AMONG"><tt>ALL-ISA-AMONG</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ALL-ISAS-WRT"><tt>ALL-ISAS-WRT</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ALL-NOT-GENL-INVERSES"><tt>ALL-NOT-GENL-INVERSES</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ALL-NOT-GENL-PREDICATES"><tt>ALL-NOT-GENL-PREDICATES</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ALL-NOT-GENLS"><tt>ALL-NOT-GENLS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ALL-NOT-ISA"><tt>ALL-NOT-ISA</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ALL-NOT-SPEC-INVERSES"><tt>ALL-NOT-SPEC-INVERSES</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ALL-NOT-SPEC-PREDICATES"><tt>ALL-NOT-SPEC-PREDICATES</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ALL-NOT-SPEC?"><tt>ALL-NOT-SPEC?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ALL-NOT-SPECS"><tt>ALL-NOT-SPECS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ALL-SPEC-ANY?"><tt>ALL-SPEC-ANY?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ALL-SPEC-ATTRIBUTES"><tt>ALL-SPEC-ATTRIBUTES</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ALL-SPEC-ATTRIBUTES-IF"><tt>ALL-SPEC-ATTRIBUTES-IF</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ALL-SPEC-INVERSES"><tt>ALL-SPEC-INVERSES</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ALL-SPEC-PREDICATES"><tt>ALL-SPEC-PREDICATES</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ALL-SPEC-PREDS-WRT-ARG"><tt>ALL-SPEC-PREDS-WRT-ARG</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ALL-SPEC-PREDS-WRT-TYPE"><tt>ALL-SPEC-PREDS-WRT-TYPE</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ALL-SPEC?"><tt>ALL-SPEC?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ALL-SPECS"><tt>ALL-SPECS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ALL-SPECS-AMONG"><tt>ALL-SPECS-AMONG</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ALL-SPECS-IF"><tt>ALL-SPECS-IF</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ALL-SUFFICIENT-DEFNS"><tt>ALL-SUFFICIENT-DEFNS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ALL-TERM-ASSERTIONS"><tt>ALL-TERM-ASSERTIONS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ANTI-SYMMETRIC-PREDICATE?"><tt>ANTI-SYMMETRIC-PREDICATE?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ANY-ALL-GENLS"><tt>ANY-ALL-GENLS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ANY-ALL-SPECS"><tt>ANY-ALL-SPECS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ANY-DISJOINT-COLLECTION-PAIR"><tt>ANY-DISJOINT-COLLECTION-PAIR</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ANY-DISJOINT-COLLECTION-PAIR?"><tt>ANY-DISJOINT-COLLECTION-PAIR?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ANY-GENL-ALL?"><tt>ANY-GENL-ALL?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ANY-GENL-ANY?"><tt>ANY-GENL-ANY?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ANY-GENL-ISA"><tt>ANY-GENL-ISA</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ANY-GENL-PREDICATE?"><tt>ANY-GENL-PREDICATE?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ANY-GENL?"><tt>ANY-GENL?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ANY-ISA-ANY?"><tt>ANY-ISA-ANY?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ANY-NOT-GENL-PREDICATE?"><tt>ANY-NOT-GENL-PREDICATE?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ANY-NOT-GENL?"><tt>ANY-NOT-GENL?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ANY-SPEC?"><tt>ANY-SPEC?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ANY-WRT-ALL-ISA"><tt>ANY-WRT-ALL-ISA</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ARGN-GENL"><tt>ARGN-GENL</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ARGN-GENL-ATTRIBUTE"><tt>ARGN-GENL-ATTRIBUTE</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ARGN-GENL-ATTRIBUTE-OF"><tt>ARGN-GENL-ATTRIBUTE-OF</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ARGN-GENL-OF"><tt>ARGN-GENL-OF</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ARGN-ISA"><tt>ARGN-ISA</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ARGN-ISA-OF"><tt>ARGN-ISA-OF</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ARGUMENT-EQUAL"><tt>ARGUMENT-EQUAL</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ARGUMENT-P"><tt>ARGUMENT-P</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ARGUMENT-STRENGTH"><tt>ARGUMENT-STRENGTH</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ARGUMENT-TRUTH"><tt>ARGUMENT-TRUTH</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ARITY"><tt>ARITY</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ASSERTED-ARGUMENT-P"><tt>ASSERTED-ARGUMENT-P</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ASSERTED-ASSERTION?"><tt>ASSERTED-ASSERTION?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ASSERTED-BY"><tt>ASSERTED-BY</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ASSERTED-WHEN"><tt>ASSERTED-WHEN</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ASSERTION-CNF"><tt>ASSERTION-CNF</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ASSERTION-COUNT"><tt>ASSERTION-COUNT</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ASSERTION-DIRECTION"><tt>ASSERTION-DIRECTION</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ASSERTION-EL-FORMULA"><tt>ASSERTION-EL-FORMULA</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ASSERTION-EL-IST-FORMULA"><tt>ASSERTION-EL-IST-FORMULA</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ASSERTION-FORMULA"><tt>ASSERTION-FORMULA</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ASSERTION-HAS-DEPENDENTS-P"><tt>ASSERTION-HAS-DEPENDENTS-P</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ASSERTION-HAS-META-ASSERTIONS?"><tt>ASSERTION-HAS-META-ASSERTIONS?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ASSERTION-HAS-TRUTH"><tt>ASSERTION-HAS-TRUTH</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ASSERTION-ID"><tt>ASSERTION-ID</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ASSERTION-IST-FORMULA"><tt>ASSERTION-IST-FORMULA</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ASSERTION-MENTIONS-TERM"><tt>ASSERTION-MENTIONS-TERM</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ASSERTION-MT"><tt>ASSERTION-MT</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ASSERTION-P"><tt>ASSERTION-P</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ASSERTION-STRENGTH"><tt>ASSERTION-STRENGTH</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ASSERTION-TRUTH"><tt>ASSERTION-TRUTH</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ASSERTIONS-MENTIONING-TERMS"><tt>ASSERTIONS-MENTIONING-TERMS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ASYMMETRIC-PREDICATE?"><tt>ASYMMETRIC-PREDICATE?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ATOMIC-CLAUSE-P"><tt>ATOMIC-CLAUSE-P</tt></a> function<index-fn-ref> 

<a name=Index-B></a><h4> B </h4>

<br>
<a href="#FN-DEF-BACKWARD-ASSERTION?"><tt>BACKWARD-ASSERTION?</tt></a> function<index-fn-ref>
<br>
<a href="#FN-DEF-BINARY-PREDICATE?"><tt>BINARY-PREDICATE?</tt></a> function<index-fn-ref>

<a name=Index-C></a><h4> C </h4>

<br>
<a href="#FN-DEF-CLAUSE-EQUAL"><tt>CLAUSE-EQUAL</tt></a> function<index-fn-ref>
<br>
<a href="#FN-DEF-CLAUSE-LITERAL"><tt>CLAUSE-LITERAL</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-CLAUSE-P"><tt>CLAUSE-P</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-CLAUSE-WITHOUT-LITERAL"><tt>CLAUSE-WITHOUT-LITERAL</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-CNF-FORMULA"><tt>CNF-FORMULA</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-CNF-FORMULA-FROM-CLAUSES"><tt>CNF-FORMULA-FROM-CLAUSES</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-CNF-P"><tt>CNF-P</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-CODE-ASSERTION?"><tt>CODE-ASSERTION?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-COLLECTION-LEAVES"><tt>COLLECTION-LEAVES</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-COLLECTIONS-COEXTENSIONAL?"><tt>COLLECTIONS-COEXTENSIONAL?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-COLLECTIONS-DISJOINT?"><tt>COLLECTIONS-DISJOINT?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-COLLECTIONS-INTERSECT?"><tt>COLLECTIONS-INTERSECT?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-COMMENT"><tt>COMMENT</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-COMMUTATIVE-FUNCTION?"><tt>COMMUTATIVE-FUNCTION?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-COMMUTATIVE-RELATION?"><tt>COMMUTATIVE-RELATION?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-CONSTANT-APROPOS"><tt>CONSTANT-APROPOS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-CONSTANT-COMPLETE"><tt>CONSTANT-COMPLETE</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-CONSTANT-COMPLETE-EXACT"><tt>CONSTANT-COMPLETE-EXACT</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-CONSTANT-COUNT"><tt>CONSTANT-COUNT</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-CONSTANT-EXTERNAL-ID"><tt>CONSTANT-EXTERNAL-ID</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-CONSTANT-INTERNAL-ID"><tt>CONSTANT-INTERNAL-ID</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-CONSTANT-NAME"><tt>CONSTANT-NAME</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-CONSTANT-P"><tt>CONSTANT-P</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-COUNT-ALL-INSTANCES"><tt>COUNT-ALL-INSTANCES</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-CREATE-CONSTANT"><tt>CREATE-CONSTANT</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-CREATION-TIME"><tt>CREATION-TIME</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-CREATOR"><tt>CREATOR</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-CYC-ADD-ARGUMENT"><tt>CYC-ADD-ARGUMENT</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-CYC-ASSERT"><tt>CYC-ASSERT</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-CYC-CONTINUE-QUERY"><tt>CYC-CONTINUE-QUERY</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-CYC-CREATE"><tt>CYC-CREATE</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-CYC-CREATE-NEW-EPHEMERAL"><tt>CYC-CREATE-NEW-EPHEMERAL</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-CYC-CREATE-NEW-PERMANENT"><tt>CYC-CREATE-NEW-PERMANENT</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-CYC-EDIT"><tt>CYC-EDIT</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-CYC-FIND-OR-CREATE"><tt>CYC-FIND-OR-CREATE</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-CYC-KILL"><tt>CYC-KILL</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-CYC-MERGE"><tt>CYC-MERGE</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-CYC-QUERY"><tt>CYC-QUERY</tt></a> function<index-fn-ref>
<br>
<a href="#FN-DEF-CYC-RECREATE"><tt>CYC-RECREATE</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-CYC-REMOVE-ALL-ARGUMENTS"><tt>CYC-REMOVE-ALL-ARGUMENTS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-CYC-REMOVE-ARGUMENT"><tt>CYC-REMOVE-ARGUMENT</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-CYC-RENAME"><tt>CYC-RENAME</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-CYC-REWRITE"><tt>CYC-REWRITE</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-CYC-TMS-RECONSIDER-SENTENCE"><tt>CYC-TMS-RECONSIDER-SENTENCE</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-CYC-UNASSERT"><tt>CYC-UNASSERT</tt></a> function<index-fn-ref> 

<a name=Index-D></a><h4> D </h4>

<br>
<a href="#FN-DEF-DEDUCED-ASSERTION?"><tt>DEDUCED-ASSERTION?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-DEDUCTION-ASSERTION"><tt>DEDUCTION-ASSERTION</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-DEDUCTION-COUNT"><tt>DEDUCTION-COUNT</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-DEDUCTION-ID"><tt>DEDUCTION-ID</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-DEDUCTION-P"><tt>DEDUCTION-P</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-DEFAULT-EL-VAR-FOR-HL-VAR"><tt>DEFAULT-EL-VAR-FOR-HL-VAR</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-DEFINING-DEFNS"><tt>DEFINING-DEFNS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-DIAGNOSE-EL-FORMULA"><tt>DIAGNOSE-EL-FORMULA</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-DIRECTION-P"><tt>DIRECTION-P</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-DNF-FORMULA"><tt>DNF-FORMULA</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-DNF-FORMULA-FROM-CLAUSES"><tt>DNF-FORMULA-FROM-CLAUSES</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-DO-ASSERTIONS"><tt>DO-ASSERTIONS</tt></a> macro<index-fn-ref> 
<br>
<a href="#FN-DEF-DO-CONSTANTS"><tt>DO-CONSTANTS</tt></a> macro<index-fn-ref> 
<br>
<a href="#FN-DEF-DO-DEDUCTIONS"><tt>DO-DEDUCTIONS</tt></a> macro<index-fn-ref> 
<br>
<a href="#FN-DEF-DO-FORTS"><tt>DO-FORTS</tt></a> macro<index-fn-ref> 
<br>
<a href="#FN-DEF-DO-NARTS"><tt>DO-NARTS</tt></a> macro<index-fn-ref>

<a name=Index-E></a><h4> E </h4>

<br>
<a href="#FN-DEF-EL-FORMULA-OK?"><tt>EL-FORMULA-OK?</tt></a> function<index-fn-ref>
<br>
<a href="#FN-DEF-EL-QUERY-OK?"><tt>EL-QUERY-OK?</tt></a> function<index-fn-ref>
<br>
<a href="#FN-DEF-EL-STRENGTH-P"><tt>EL-STRENGTH-P</tt></a> function<index-fn-ref>
<br>
<a href="#FN-DEF-EL-TO-HL-QUERY"><tt>EL-TO-HL-QUERY</tt></a> function<index-fn-ref>
<br>
<a href="#FN-DEF-EL-TO-HL"><tt>EL-TO-HL</tt></a> function<index-fn-ref>
<br>
<a href="#FN-DEF-EL-VAR?"><tt>EL-VAR?</tt></a> function<index-fn-ref>
<br>
<a href="#FN-DEF-EL-WFF-SYNTAX+ARITY?"><tt>EL-WFF-SYNTAX+ARITY?</tt></a> function<index-fn-ref>
<br>
<a href="#FN-DEF-EL-WFF-SYNTAX?"><tt>EL-WFF-SYNTAX?</tt></a> function<index-fn-ref>
<br>
<a href="#FN-DEF-EMPTY-CLAUSE"><tt>EMPTY-CLAUSE</tt></a> function<index-fn-ref>
<br>
<a href="#FN-DEF-EMPTY-CLAUSE?"><tt>EMPTY-CLAUSE?</tt></a> function<index-fn-ref>

<a name=Index-F></a><h4> F </h4>

<br>
<a href="#FN-DEF-FI-ASK"><tt>FI-ASK</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-FI-ASK-STATUS"><tt>FI-ASK-STATUS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-FI-ASSERT"><tt>FI-ASSERT</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-FI-BLAST"><tt>FI-BLAST</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-FI-COMPLETE"><tt>FI-COMPLETE</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-FI-CONTINUE-LAST-ASK"><tt>FI-CONTINUE-LAST-ASK</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-FI-CREATE"><tt>FI-CREATE</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-FI-EDIT"><tt>FI-EDIT</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-FI-FIND"><tt>FI-FIND</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-FI-FIND-OR-CREATE"><tt>FI-FIND-OR-CREATE</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-FI-GET-ERROR"><tt>FI-GET-ERROR</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-FI-GET-WARNING"><tt>FI-GET-WARNING</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-FI-HYPOTHESIZE"><tt>FI-HYPOTHESIZE</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-FI-KILL"><tt>FI-KILL</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-FI-LOOKUP"><tt>FI-LOOKUP</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-FI-PROVE"><tt>FI-PROVE</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-FI-RENAME"><tt>FI-RENAME</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-FI-TMS-RECONSIDER-FORMULA"><tt>FI-TMS-RECONSIDER-FORMULA</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-FI-TMS-RECONSIDER-GAFS"><tt>FI-TMS-RECONSIDER-GAFS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-FI-TMS-RECONSIDER-MT"><tt>FI-TMS-RECONSIDER-MT</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-FI-TMS-RECONSIDER-TERM"><tt>FI-TMS-RECONSIDER-TERM</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-FI-UNASSERT"><tt>FI-UNASSERT</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-FIND-ALL-ASSERTIONS"><tt>FIND-ALL-ASSERTIONS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-FIND-ALL-GAFS"><tt>FIND-ALL-GAFS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-FIND-ASSERTION"><tt>FIND-ASSERTION</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-FIND-ASSERTION-ANY-MT"><tt>FIND-ASSERTION-ANY-MT</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-FIND-ASSERTION-BY-ID"><tt>FIND-ASSERTION-BY-ID</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-FIND-CONSTANT"><tt>FIND-CONSTANT</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-FIND-CONSTANT-BY-EXTERNAL-ID"><tt>FIND-CONSTANT-BY-EXTERNAL-ID</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-FIND-CONSTANT-BY-INTERNAL-ID"><tt>FIND-CONSTANT-BY-INTERNAL-ID</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-FIND-CONSTANT-INFO-BY-EXTERNAL-ID"><tt>FIND-CONSTANT-INFO-BY-EXTERNAL-ID</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-FIND-DEDUCTION-BY-ID"><tt>FIND-DEDUCTION-BY-ID</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-FIND-GAF"><tt>FIND-GAF</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-FIND-GAF-ANY-MT"><tt>FIND-GAF-ANY-MT</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-FIND-NART-BY-ID"><tt>FIND-NART-BY-ID</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-FIND-OR-CREATE-CONSTANT"><tt>FIND-OR-CREATE-CONSTANT</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-FIND-VARIABLE-BY-ID"><tt>FIND-VARIABLE-BY-ID</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-FORT-COUNT"><tt>FORT-COUNT</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-FORT-EL-FORMULA"><tt>FORT-EL-FORMULA</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-FORT-P"><tt>FORT-P</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-FORWARD-ASSERTION?"><tt>FORWARD-ASSERTION?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-FPRED-VALUE"><tt>FPRED-VALUE</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-FPRED-VALUE-IN-ANY-MT"><tt>FPRED-VALUE-IN-ANY-MT</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-FPRED-VALUE-IN-MT"><tt>FPRED-VALUE-IN-MT</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-FPRED-VALUE-IN-MTS"><tt>FPRED-VALUE-IN-MTS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-FPRED-VALUE-IN-RELEVANT-MTS"><tt>FPRED-VALUE-IN-RELEVANT-MTS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-FULLY-BOUND-P"><tt>FULLY-BOUND-P</tt></a> function<index-fn-ref>

<a name=Index-G></a><h4> G </h4>

<br>
<a href="#FN-DEF-GAF-CNF?"><tt>GAF-CNF?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GATHER-EXCEPTION-RULE-INDEX"><tt>GATHER-EXCEPTION-RULE-INDEX</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GATHER-FUNCTION-EXTENT-INDEX"><tt>GATHER-FUNCTION-EXTENT-INDEX</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GATHER-FUNCTION-RULE-INDEX"><tt>GATHER-FUNCTION-RULE-INDEX</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GATHER-GAF-ARG-INDEX"><tt>GATHER-GAF-ARG-INDEX</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GATHER-GENL-MT-RULE-INDEX"><tt>GATHER-GENL-MT-RULE-INDEX</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GATHER-GENLS-RULE-INDEX"><tt>GATHER-GENLS-RULE-INDEX</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GATHER-INDEX"><tt>GATHER-INDEX</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GATHER-INDEX-IN-ANY-MT"><tt>GATHER-INDEX-IN-ANY-MT</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GATHER-ISA-RULE-INDEX"><tt>GATHER-ISA-RULE-INDEX</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GATHER-MT-INDEX"><tt>GATHER-MT-INDEX</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GATHER-NART-ARG-INDEX"><tt>GATHER-NART-ARG-INDEX</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GATHER-OTHER-INDEX"><tt>GATHER-OTHER-INDEX</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GATHER-PREDICATE-EXTENT-INDEX"><tt>GATHER-PREDICATE-EXTENT-INDEX</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GATHER-PREDICATE-RULE-INDEX"><tt>GATHER-PREDICATE-RULE-INDEX</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GATHER-TERM-ASSERTIONS"><tt>GATHER-TERM-ASSERTIONS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GENL-INVERSE-SIBLINGS"><tt>GENL-INVERSE-SIBLINGS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GENL-INVERSE?"><tt>GENL-INVERSE?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GENL-INVERSES"><tt>GENL-INVERSES</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GENL-PREDICATE-SIBLINGS"><tt>GENL-PREDICATE-SIBLINGS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GENL-PREDICATE?"><tt>GENL-PREDICATE?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GENL-PREDICATES"><tt>GENL-PREDICATES</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GENL-SIBLINGS"><tt>GENL-SIBLINGS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GENL?"><tt>GENL?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GET-ASSERTED-ARGUMENT"><tt>GET-ASSERTED-ARGUMENT</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GROUND-CLAUSE-P"><tt>GROUND-CLAUSE-P</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GROUND?"><tt>GROUND?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GT-ALL-ACCESSIBLE"><tt>GT-ALL-ACCESSIBLE</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GT-ALL-DEPENDENT-INFERIORS"><tt>GT-ALL-DEPENDENT-INFERIORS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GT-ALL-INFERIORS"><tt>GT-ALL-INFERIORS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GT-ALL-SUPERIORS"><tt>GT-ALL-SUPERIORS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GT-ANY-SUPERIOR-PATH"><tt>GT-ANY-SUPERIOR-PATH</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GT-CO-INFERIORS"><tt>GT-CO-INFERIORS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GT-CO-SUPERIORS"><tt>GT-CO-SUPERIORS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GT-COMPLETES-CYCLE?"><tt>GT-COMPLETES-CYCLE?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GT-COMPOSE-FN-ALL-INFERIORS"><tt>GT-COMPOSE-FN-ALL-INFERIORS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GT-COMPOSE-FN-ALL-SUPERIORS"><tt>GT-COMPOSE-FN-ALL-SUPERIORS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GT-COMPOSE-PRED-ALL-INFERIORS"><tt>GT-COMPOSE-PRED-ALL-INFERIORS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GT-COMPOSE-PRED-ALL-SUPERIORS"><tt>GT-COMPOSE-PRED-ALL-SUPERIORS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GT-CYCLES?"><tt>GT-CYCLES?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GT-HAS-INFERIOR?"><tt>GT-HAS-INFERIOR?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GT-HAS-SUPERIOR?"><tt>GT-HAS-SUPERIOR?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GT-INFERIORS"><tt>GT-INFERIORS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GT-LEAVES"><tt>GT-LEAVES</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GT-MAX-FLOORS"><tt>GT-MAX-FLOORS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GT-MAX-INFERIORS"><tt>GT-MAX-INFERIORS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GT-MAX-INFERIORS-EXCLUDING"><tt>GT-MAX-INFERIORS-EXCLUDING</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GT-MAX-NODES"><tt>GT-MAX-NODES</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GT-MIN-CEILINGS"><tt>GT-MIN-CEILINGS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GT-MIN-NODES"><tt>GT-MIN-NODES</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GT-MIN-SUPERIORS"><tt>GT-MIN-SUPERIORS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GT-MIN-SUPERIORS-EXCLUDING"><tt>GT-MIN-SUPERIORS-EXCLUDING</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GT-REDUNDANT-INFERIORS"><tt>GT-REDUNDANT-INFERIORS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GT-REDUNDANT-SUPERIORS"><tt>GT-REDUNDANT-SUPERIORS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GT-ROOTS"><tt>GT-ROOTS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GT-SUPERIORS"><tt>GT-SUPERIORS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GT-WHY-COMPLETES-CYCLE?"><tt>GT-WHY-COMPLETES-CYCLE?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-GT-WHY-SUPERIOR?"><tt>GT-WHY-SUPERIOR?</tt></a> function<index-fn-ref> 


<a name=Index-H></a><h4> H </h4>

<br>
<a href="#FN-DEF-HL-MODULE-P"><tt>HL-MODULE-P</tt></a> function<index-fn-ref>
<br>
<a href="#FN-DEF-HL-SUPPORT-P"><tt>HL-SUPPORT-P</tt></a> function<index-fn-ref>
<br>
<a href="#FN-DEF-HL-TERM-P"><tt>HL-TERM-P</tt></a> function<index-fn-ref> 

<a name=Index-I></a><h4> I </h4>

<br>
<a href="#FN-DEF-INDEXED-TERM-P"><tt>INDEXED-TERM-P</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-INSTANCE-SIBLINGS"><tt>INSTANCE-SIBLINGS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-INSTANCES"><tt>INSTANCES</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-INSTANCES?"><tt>INSTANCES?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-INTERSECTING-PREDICATES?"><tt>INTERSECTING-PREDICATES?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-IRREFLEXIVE-PREDICATE?"><tt>IRREFLEXIVE-PREDICATE?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ISA-ANY?"><tt>ISA-ANY?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ISA-RELEVANT-ASSERTIONS"><tt>ISA-RELEVANT-ASSERTIONS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ISA-RELEVANT-ASSERTIONS-WRT-TYPE"><tt>ISA-RELEVANT-ASSERTIONS-WRT-TYPE</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ISA-SIBLINGS"><tt>ISA-SIBLINGS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-ISA?"><tt>ISA?</tt></a> function<index-fn-ref> 

<a name=Index-J></a><h4> J </h4>

<a name=Index-K></a><h4> K </h4>

<br>
<a href="#FN-DEF-KEY-EXCEPTION-RULE-INDEX"><tt>KEY-EXCEPTION-RULE-INDEX</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-KEY-FUNCTION-RULE-INDEX"><tt>KEY-FUNCTION-RULE-INDEX</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-KEY-GAF-ARG-INDEX"><tt>KEY-GAF-ARG-INDEX</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-KEY-GENL-MT-RULE-INDEX"><tt>KEY-GENL-MT-RULE-INDEX</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-KEY-GENLS-RULE-INDEX"><tt>KEY-GENLS-RULE-INDEX</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-KEY-ISA-RULE-INDEX"><tt>KEY-ISA-RULE-INDEX</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-KEY-NART-ARG-INDEX"><tt>KEY-NART-ARG-INDEX</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-KEY-PREDICATE-EXTENT-INDEX"><tt>KEY-PREDICATE-EXTENT-INDEX</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-KEY-PREDICATE-RULE-INDEX"><tt>KEY-PREDICATE-RULE-INDEX</tt></a> function<index-fn-ref> 

<a name=Index-L></a><h4> L </h4>

<br>
<a href="#FN-DEF-LIGHTER-COL"><tt>LIGHTER-COL</tt></a> function<index-fn-ref>

<a name=Index-M></a><h4> M </h4>

<br>
<a href="#FN-DEF-MAKE-CLAUSE"><tt>MAKE-CLAUSE</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-MAKE-HL-SUPPORT"><tt>MAKE-HL-SUPPORT</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-MAP-ALL-GENL-PREDS"><tt>MAP-ALL-GENL-PREDS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-MAP-ALL-GENLS"><tt>MAP-ALL-GENLS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-MAP-ALL-INSTANCES"><tt>MAP-ALL-INSTANCES</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-MAP-ALL-ISA"><tt>MAP-ALL-ISA</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-MAP-ALL-SPEC-PREDS"><tt>MAP-ALL-SPEC-PREDS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-MAP-ALL-SPECS"><tt>MAP-ALL-SPECS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-MAP-INSTANCES"><tt>MAP-INSTANCES</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-MAP-MT-CONTENTS"><tt>MAP-MT-CONTENTS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-MAP-MT-INDEX"><tt>MAP-MT-INDEX</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-MAP-MTS"><tt>MAP-MTS</tt></a> macro<index-fn-ref> 
<br>
<a href="#FN-DEF-MAP-OTHER-INDEX"><tt>MAP-OTHER-INDEX</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-MAP-TERM"><tt>MAP-TERM</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-MAP-TERM-GAFS"><tt>MAP-TERM-GAFS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-MAP-TERM-SELECTIVE"><tt>MAP-TERM-SELECTIVE</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-MAX-COLS"><tt>MAX-COLS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-MAX-FLOOR-COLS"><tt>MAX-FLOOR-COLS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-MAX-FLOOR-MTS-OF-GENL-INVERSE-PATHS"><tt>MAX-FLOOR-MTS-OF-GENL-INVERSE-PATHS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-MAX-FLOOR-MTS-OF-GENL-PREDICATE-PATHS"><tt>MAX-FLOOR-MTS-OF-GENL-PREDICATE-PATHS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-MAX-FLOOR-MTS-OF-GENLS-PATHS"><tt>MAX-FLOOR-MTS-OF-GENLS-PATHS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-MAX-FLOOR-MTS-OF-ISA-PATHS"><tt>MAX-FLOOR-MTS-OF-ISA-PATHS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-MAX-FLOOR-PREDICATES"><tt>MAX-FLOOR-PREDICATES</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-MAX-INSTANCES"><tt>MAX-INSTANCES</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-MAX-NOT-GENL-INVERSES"><tt>MAX-NOT-GENL-INVERSES</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-MAX-NOT-GENL-PREDICATES"><tt>MAX-NOT-GENL-PREDICATES</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-MAX-NOT-GENLS"><tt>MAX-NOT-GENLS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-MAX-NOT-ISA"><tt>MAX-NOT-ISA</tt></a> function<index-fn-ref>
<br>
<a href="#FN-DEF-MAX-PREDICATES"><tt>MAX-PREDICATES</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-MAX-SPEC-INVERSES"><tt>MAX-SPEC-INVERSES</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-MAX-SPEC-PREDICATES"><tt>MAX-SPEC-PREDICATES</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-MAX-SPECS"><tt>MAX-SPECS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-MIN-ARGN-GENL"><tt>MIN-ARGN-GENL</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-MIN-ARGN-GENL-ATTRIBUTE"><tt>MIN-ARGN-GENL-ATTRIBUTE</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-MIN-ARGN-ISA"><tt>MIN-ARGN-ISA</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-MIN-CEILING-COLS"><tt>MIN-CEILING-COLS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-MIN-CEILING-PREDICATES"><tt>MIN-CEILING-PREDICATES</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-MIN-COLS"><tt>MIN-COLS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-MIN-GENL-INVERSES"><tt>MIN-GENL-INVERSES</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-MIN-GENL-PREDICATES"><tt>MIN-GENL-PREDICATES</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-MIN-GENLS"><tt>MIN-GENLS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-MIN-ISA"><tt>MIN-ISA</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-MIN-NOT-INSTANCES"><tt>MIN-NOT-INSTANCES</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-MIN-NOT-SPEC-INVERSES"><tt>MIN-NOT-SPEC-INVERSES</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-MIN-NOT-SPEC-PREDICATES"><tt>MIN-NOT-SPEC-PREDICATES</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-MIN-NOT-SPECS"><tt>MIN-NOT-SPECS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-MIN-PREDICATES"><tt>MIN-PREDICATES</tt></a> function<index-fn-ref> 

<a name=Index-N></a><h4> N </h4>

<br>
<a href="#FN-DEF-NART-COUNT"><tt>NART-COUNT</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-NART-EL-FORMULA"><tt>NART-EL-FORMULA</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-NART-HL-FORMULA"><tt>NART-HL-FORMULA</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-NART-ID"><tt>NART-ID</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-NART-P"><tt>NART-P</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-NAT-P"><tt>NAT-P</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-NECESSARY-DEFNS"><tt>NECESSARY-DEFNS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-NEG-LITS"><tt>NEG-LITS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-NEGATE"><tt>NEGATE</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-NEGATED?"><tt>NEGATED?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-NOT-GENL-INVERSE?"><tt>NOT-GENL-INVERSE?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-NOT-GENL-INVERSES"><tt>NOT-GENL-INVERSES</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-NOT-GENL-PREDICATE?"><tt>NOT-GENL-PREDICATE?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-NOT-GENL-PREDICATES"><tt>NOT-GENL-PREDICATES</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-NOT-GENL?"><tt>NOT-GENL?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-NOT-ISA-AMONG"><tt>NOT-ISA-AMONG</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-NOT-ISA?"><tt>NOT-ISA?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-NOT-SPEC-INVERSES"><tt>NOT-SPEC-INVERSES</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-NOT-SPEC-PREDICATES"><tt>NOT-SPEC-PREDICATES</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-NUM-EXCEPTION-RULE-INDEX"><tt>NUM-EXCEPTION-RULE-INDEX</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-NUM-FUNCTION-EXTENT-INDEX"><tt>NUM-FUNCTION-EXTENT-INDEX</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-NUM-FUNCTION-RULE-INDEX"><tt>NUM-FUNCTION-RULE-INDEX</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-NUM-GAF-ARG-INDEX"><tt>NUM-GAF-ARG-INDEX</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-NUM-GENL-MT-RULE-INDEX"><tt>NUM-GENL-MT-RULE-INDEX</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-NUM-GENLS-RULE-INDEX"><tt>NUM-GENLS-RULE-INDEX</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-NUM-INDEX"><tt>NUM-INDEX</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-NUM-ISA-RULE-INDEX"><tt>NUM-ISA-RULE-INDEX</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-NUM-MT-INDEX"><tt>NUM-MT-INDEX</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-NUM-NART-ARG-INDEX"><tt>NUM-NART-ARG-INDEX</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-NUM-OTHER-INDEX"><tt>NUM-OTHER-INDEX</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-NUM-PREDICATE-EXTENT-INDEX"><tt>NUM-PREDICATE-EXTENT-INDEX</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-NUM-PREDICATE-RULE-INDEX"><tt>NUM-PREDICATE-RULE-INDEX</tt></a> function<index-fn-ref>

<a name=Index-O></a><h4> O </h4>

<a name=Index-P></a><h4> P </h4>

<br>
<a href="#FN-DEF-POS-LITS"><tt>POS-LITS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-PRED-REFS"><tt>PRED-REFS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-PRED-REFS-IN-ANY-MT"><tt>PRED-REFS-IN-ANY-MT</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-PRED-REFS-IN-MT"><tt>PRED-REFS-IN-MT</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-PRED-REFS-IN-MTS"><tt>PRED-REFS-IN-MTS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-PRED-REFS-IN-RELEVANT-MTS"><tt>PRED-REFS-IN-RELEVANT-MTS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-PRED-U-V-HOLDS"><tt>PRED-U-V-HOLDS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-PRED-U-V-HOLDS-IN-ANY-MT"><tt>PRED-U-V-HOLDS-IN-ANY-MT</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-PRED-U-V-HOLDS-IN-MT"><tt>PRED-U-V-HOLDS-IN-MT</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-PRED-U-V-HOLDS-IN-MTS"><tt>PRED-U-V-HOLDS-IN-MTS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-PRED-U-V-HOLDS-IN-RELEVANT-MTS"><tt>PRED-U-V-HOLDS-IN-RELEVANT-MTS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-PRED-VALUE-TUPLES"><tt>PRED-VALUE-TUPLES</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-PRED-VALUE-TUPLES-IN-ANY-MT"><tt>PRED-VALUE-TUPLES-IN-ANY-MT</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-PRED-VALUE-TUPLES-IN-MT"><tt>PRED-VALUE-TUPLES-IN-MT</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-PRED-VALUE-TUPLES-IN-MTS"><tt>PRED-VALUE-TUPLES-IN-MTS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-PRED-VALUE-TUPLES-IN-RELEVANT-MTS"><tt>PRED-VALUE-TUPLES-IN-RELEVANT-MTS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-PRED-VALUES"><tt>PRED-VALUES</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-PRED-VALUES-IN-ANY-MT"><tt>PRED-VALUES-IN-ANY-MT</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-PRED-VALUES-IN-MT"><tt>PRED-VALUES-IN-MT</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-PRED-VALUES-IN-MTS"><tt>PRED-VALUES-IN-MTS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-PRED-VALUES-IN-RELEVANT-MTS"><tt>PRED-VALUES-IN-RELEVANT-MTS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-PREDS-FOR-PAIR"><tt>PREDS-FOR-PAIR</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-PRIMITIVE-COLLECTION?"><tt>PRIMITIVE-COLLECTION?</tt></a> function<index-fn-ref> 

<a name=Index-Q></a><h4> Q </h4>

<a name=Index-R></a><h4> R </h4>

<br>
<a href="#FN-DEF-REFLEXIVE-PREDICATE?"><tt>REFLEXIVE-PREDICATE?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-RELATION?"><tt>RELATION?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-RELEVANT-NUM-FUNCTION-EXTENT-INDEX"><tt>RELEVANT-NUM-FUNCTION-EXTENT-INDEX</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-RELEVANT-NUM-GAF-ARG-INDEX"><tt>RELEVANT-NUM-GAF-ARG-INDEX</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-RELEVANT-NUM-NART-ARG-INDEX"><tt>RELEVANT-NUM-NART-ARG-INDEX</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-RELEVANT-NUM-PREDICATE-EXTENT-INDEX"><tt>RELEVANT-NUM-PREDICATE-EXTENT-INDEX</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-REMOVE-CONSTANT"><tt>REMOVE-CONSTANT</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-REMOVE-FORT"><tt>REMOVE-FORT</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-REMOVE-NART"><tt>REMOVE-NART</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-REMOVE-TERM-INDICES"><tt>REMOVE-TERM-INDICES</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-RENAME-CONSTANT"><tt>RENAME-CONSTANT</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-RESULT-ISA"><tt>RESULT-ISA</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-REVIEWER"><tt>REVIEWER</tt></a> function<index-fn-ref> 

<a name=Index-S></a><h4> S </h4>

<br>
<a href="#FN-DEF-SENSE-P"><tt>SENSE-P</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-SHALLOWER-COL"><tt>SHALLOWER-COL</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-SOME-ALL-GENL-INVERSES"><tt>SOME-ALL-GENL-INVERSES</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-SOME-ALL-GENL-PREDS"><tt>SOME-ALL-GENL-PREDS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-SOME-ALL-SPEC-PREDS"><tt>SOME-ALL-SPEC-PREDS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-SOME-PRED-VALUE"><tt>SOME-PRED-VALUE</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-SOME-PRED-VALUE-IN-ANY-MT"><tt>SOME-PRED-VALUE-IN-ANY-MT</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-SOME-PRED-VALUE-IN-MT"><tt>SOME-PRED-VALUE-IN-MT</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-SOME-PRED-VALUE-IN-MTS"><tt>SOME-PRED-VALUE-IN-MTS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-SOME-PRED-VALUE-IN-RELEVANT-MTS"><tt>SOME-PRED-VALUE-IN-RELEVANT-MTS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-SPEC-INVERSE-SIBLINGS"><tt>SPEC-INVERSE-SIBLINGS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-SPEC-INVERSE?"><tt>SPEC-INVERSE?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-SPEC-INVERSES"><tt>SPEC-INVERSES</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-SPEC-PREDICATE-SIBLINGS"><tt>SPEC-PREDICATE-SIBLINGS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-SPEC-PREDICATE?"><tt>SPEC-PREDICATE?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-SPEC-PREDICATES"><tt>SPEC-PREDICATES</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-SPEC-SIBLINGS"><tt>SPEC-SIBLINGS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-SPEC?"><tt>SPEC?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-SUFFICIENT-DEFNS"><tt>SUFFICIENT-DEFNS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-SUPPORT-MODULE"><tt>SUPPORT-MODULE</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-SUPPORT-MT"><tt>SUPPORT-MT</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-SUPPORT-P"><tt>SUPPORT-P</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-SUPPORT-SENTENCE"><tt>SUPPORT-SENTENCE</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-SUPPORT-STRENGTH"><tt>SUPPORT-STRENGTH</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-SUPPORT-TRUTH"><tt>SUPPORT-TRUTH</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-SYMMETRIC-PREDICATE?"><tt>SYMMETRIC-PREDICATE?</tt></a> function<index-fn-ref> 

<a name=Index-T></a><h4> T </h4>

<br>
<a href="#FN-DEF-TM-API-DELETE-THESAURUS"><tt>TM-API-DELETE-THESAURUS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-TM-OUTPUT-THESAURUS-TO-FILE"><tt>TM-OUTPUT-THESAURUS-TO-FILE</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-TRANSITIVE-PREDICATE?"><tt>TRANSITIVE-PREDICATE?</tt></a> function<index-fn-ref>
<br>
<a href="#FN-DEF-TRUTH-P"><tt>TRUTH-P</tt></a> function<index-fn-ref>

<a name=Index-U></a><h4> U </h4>

<br>
<a href="#FN-DEF-UNION-ALL-GENL-INVERSES"><tt>UNION-ALL-GENL-INVERSES</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-UNION-ALL-GENL-PREDICATES"><tt>UNION-ALL-GENL-PREDICATES</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-UNION-ALL-GENLS"><tt>UNION-ALL-GENLS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-UNION-ALL-INSTANCES"><tt>UNION-ALL-INSTANCES</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-UNION-ALL-ISA"><tt>UNION-ALL-ISA</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-UNION-ALL-SPEC-INVERSES"><tt>UNION-ALL-SPEC-INVERSES</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-UNION-ALL-SPEC-PREDICATES"><tt>UNION-ALL-SPEC-PREDICATES</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-UNION-ALL-SPECS"><tt>UNION-ALL-SPECS</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-UNIQUIFY-CONSTANT-NAME"><tt>UNIQUIFY-CONSTANT-NAME</tt></a> function<index-fn-ref> 

<a name=Index-V></a><h4> V </h4>

<br>
<a href="#FN-DEF-VALID-CONSTANT-NAME"><tt>VALID-CONSTANT-NAME</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-VALID-CONSTANT-NAME-CHAR"><tt>VALID-CONSTANT-NAME-CHAR</tt></a> function<index-fn-ref>
<br>
<a href="#FN-DEF-VARIABLE-COUNT"><tt>VARIABLE-COUNT</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-VARIABLE-ID"><tt>VARIABLE-ID</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-VARIABLE-P"><tt>VARIABLE-P</tt></a> function<index-fn-ref>

<a name=Index-W></a><h4> W </h4>

<br>
<a href="#FN-DEF-WHY-COLLECTIONS-DISJOINT?"><tt>WHY-COLLECTIONS-DISJOINT?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-WHY-GENL-INVERSE?"><tt>WHY-GENL-INVERSE?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-WHY-GENL-PREDICATE?"><tt>WHY-GENL-PREDICATE?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-WHY-GENL?"><tt>WHY-GENL?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-WHY-ISA?"><tt>WHY-ISA?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-WHY-NOT-ASSERT-GENLS?"><tt>WHY-NOT-ASSERT-GENLS?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-WHY-NOT-GENL-INVERSE?"><tt>WHY-NOT-GENL-INVERSE?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-WHY-NOT-GENL-PREDICATE?"><tt>WHY-NOT-GENL-PREDICATE?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-WHY-NOT-GENL?"><tt>WHY-NOT-GENL?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-WHY-NOT-ISA?"><tt>WHY-NOT-ISA?</tt></a> function<index-fn-ref> 
<br>
<a href="#FN-DEF-WITH-ALL-MTS"><tt>WITH-ALL-MTS</tt></a> macro<index-fn-ref> 
<br>
<a href="#FN-DEF-WITH-ANY-MT"><tt>WITH-ANY-MT</tt></a> macro<index-fn-ref> 
<br>
<a href="#FN-DEF-WITH-GENL-MTS"><tt>WITH-GENL-MTS</tt></a> macro<index-fn-ref> 
<br>
<a href="#FN-DEF-WITH-JUST-MT"><tt>WITH-JUST-MT</tt></a> macro<index-fn-ref> 
<br>
<a href="#FN-DEF-WITH-MT"><tt>WITH-MT</tt></a> macro<index-fn-ref> 
<br>
<a href="#FN-DEF-WITH-MT-LIST"><tt>WITH-MT-LIST</tt></a> macro<index-fn-ref> 

<a name=Index-X></a><h4> X </h4>

<a name=Index-Y></a><h4> Y </h4>

<a name=Index-Z></a><h4> Z </h4>
<p>
<TABLE width=100% cellpadding=0 cellspacing=0 border=0>
<TR>
<TD bgcolor="#3399FF"><img src="images/spacer.gif" width="1" height="4"></TD>
</TR>
<TR>
<TD bgcolor="#FFFFFF"><img src="images/spacer.gif" width="1" height="2"></TD>
</TR>
<TR>
<TD bgcolor="#3399FF"><img src="images/spacer.gif" width="1" height="1"></TD>
</TR>
</TABLE>
<p>
<table border="0" cellpadding="0" cellspacing="0" width="87%">
    <tr>
        <td align="right" width="35%"><!--webbot
        bot="HTMLMarkup" startspan --><a href="http://www.cyc.com"><img src="images/cyc-logo-small.gif" align="middle" border=0></a><!--webbot
        bot="HTMLMarkup" endspan --></td>
        <td width="5%"><!--webbot bot="HTMLMarkup" startspan -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--webbot
        bot="HTMLMarkup" endspan --></td>
        <td align="center" width="35%"><!--webbot bot="HTMLMarkup" startspan --><a href="http://www.daml.org"> 
  <img src="images/HotDAML_Small.jpg" alt="HotDAML" border=0 /> 
</a><!--webbot
        bot="HTMLMarkup" endspan --></td>
<td width="5%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
        <td>
<a href="http://sourceforge.net"><img src="http://sourceforge.net/sflogo.php?group_id=27274&type=4" width="125" height="37" border="0" alt="SourceForge.net Logo"></a>
    </td></tr>
</table>
</td>
</tr>
</table>
</body>
</html>
